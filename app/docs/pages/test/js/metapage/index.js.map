{"version":3,"sources":["../../node_modules/eventemitter3/index.js","../../node_modules/process/browser.js","../../node_modules/path-browserify/index.js","../../node_modules/concat-map/index.js","../../node_modules/balanced-match/index.js","../../node_modules/brace-expansion/index.js","../../node_modules/minimatch/minimatch.js","MetaLibsVersion.ts","Constants.ts","v0_3/JsonRpcMethods.ts","../../node_modules/compare-versions/index.js","MetapageTools.ts","Metapage.ts"],"names":["process","module","exports","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","Error","defaultClearTimeout","setTimeout","e","clearTimeout","runTimeout","fun","call","runClearTimeout","marker","queue","draining","currentQueue","queueIndex","cleanUpNextTick","length","concat","drainQueue","timeout","len","run","nextTick","args","Array","arguments","i","push","Item","array","prototype","apply","title","env","argv","version","versions","noop","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","name","binding","cwd","chdir","dir","umask"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AChVA;AACA,IAAIA,OAAO,GAAGC,MAAM,CAACC,OAAP,GAAiB,EAA/B,EAEA;AACA;AACA;AACA;;AAEA,IAAIC,gBAAJ;AACA,IAAIC,kBAAJ;;AAEA,SAASC,gBAAT,GAA4B;AACxB,QAAM,IAAIC,KAAJ,CAAU,iCAAV,CAAN;AACH;;AACD,SAASC,mBAAT,GAAgC;AAC5B,QAAM,IAAID,KAAJ,CAAU,mCAAV,CAAN;AACH;;AACA,aAAY;AACT,MAAI;AACA,QAAI,OAAOE,UAAP,KAAsB,UAA1B,EAAsC;AAClCL,MAAAA,gBAAgB,GAAGK,UAAnB;AACH,KAFD,MAEO;AACHL,MAAAA,gBAAgB,GAAGE,gBAAnB;AACH;AACJ,GAND,CAME,OAAOI,CAAP,EAAU;AACRN,IAAAA,gBAAgB,GAAGE,gBAAnB;AACH;;AACD,MAAI;AACA,QAAI,OAAOK,YAAP,KAAwB,UAA5B,EAAwC;AACpCN,MAAAA,kBAAkB,GAAGM,YAArB;AACH,KAFD,MAEO;AACHN,MAAAA,kBAAkB,GAAGG,mBAArB;AACH;AA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QAAM,IAAI/C,KAAJ,CAAU,kCAAV,CAAN;AACH,CAFD;;AAIAN,OAAO,CAACuD,GAAR,GAAc,YAAY;AAAE,SAAO,GAAP;AAAY,CAAxC;;AACAvD,OAAO,CAACwD,KAAR,GAAgB,UAAUC,GAAV,EAAe;AAC3B,QAAM,IAAInD,KAAJ,CAAU,gCAAV,CAAN;AACH,CAFD;;AAGAN,OAAO,CAAC0D,KAAR,GAAgB,YAAW;AAAE,SAAO,CAAP;AAAW,CAAxC;;;ACvLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC15BA,IAAY,QAAZ;;;AAAA,CAAA,UAAY,QAAZ,EAAoB;AACnB,EAAA,QAAA,CAAA,QAAA,CAAA,GAAA,OAAA;AACA,EAAA,QAAA,CAAA,QAAA,CAAA,GAAA,OAAA;AACA,EAAA,QAAA,CAAA,MAAA,CAAA,GAAA,KAAA;AACA,EAAA,QAAA,CAAA,MAAA,CAAA,GAAA,KAAA;AACE,CALH,EAAY,QAAQ,wBAAR,QAAQ,GAAA,EAAA,CAApB;;AAOO,MAAM,WAAW,GAAG,MAAM,CAAC,IAAP,CAAY,QAAZ,CAApB;;AAEA,MAAM,cAAc,GAAG,QAAQ,CAAC,IAAhC;;;;;;;;;;ACVP;;AAEO,MAAM,mBAAmB,GAAG,gBAA5B;;AACA,MAAM,uBAAuB,GAAG,qBAAhC;;AACA,MAAM,kBAAkB,GAAG,gBAA3B;;AACA,MAAM,eAAe,GAAG,UAAxB;;AAEA,MAAM,OAAO,GAAG,6BAAY,6BAAY,MAAZ,GAAqB,CAAjC,CAAhB;;;;;;;;;ACHP,IAAY,uBAAZ;;;AAAA,CAAA,UAAY,uBAAZ,EAAmC;AACjC,EAAA,uBAAA,CAAA,cAAA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","file":"index.js","sourceRoot":"../../../../src/metapage","sourcesContent":["'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,\n// backported and transplited with Babel, with backwards-compat fixes\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function (path) {\n  if (typeof path !== 'string') path = path + '';\n  if (path.length === 0) return '.';\n  var code = path.charCodeAt(0);\n  var hasRoot = code === 47 /*/*/;\n  var end = -1;\n  var matchedSlash = true;\n  for (var i = path.length - 1; i >= 1; --i) {\n    code = path.charCodeAt(i);\n    if (code === 47 /*/*/) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n      // We saw the first non-path separator\n      matchedSlash = false;\n    }\n  }\n\n  if (end === -1) return hasRoot ? '/' : '.';\n  if (hasRoot && end === 1) {\n    // return '//';\n    // Backwards-compat fix:\n    return '/';\n  }\n  return path.slice(0, end);\n};\n\nfunction basename(path) {\n  if (typeof path !== 'string') path = path + '';\n\n  var start = 0;\n  var end = -1;\n  var matchedSlash = true;\n  var i;\n\n  for (i = path.length - 1; i >= 0; --i) {\n    if (path.charCodeAt(i) === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // path component\n      matchedSlash = false;\n      end = i + 1;\n    }\n  }\n\n  if (end === -1) return '';\n  return path.slice(start, end);\n}\n\n// Uses a mixed approach for backwards-compatibility, as ext behavior changed\n// in new Node.js versions, so only basename() above is backported here\nexports.basename = function (path, ext) {\n  var f = basename(path);\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\nexports.extname = function (path) {\n  if (typeof path !== 'string') path = path + '';\n  var startDot = -1;\n  var startPart = 0;\n  var end = -1;\n  var matchedSlash = true;\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find\n  var preDotState = 0;\n  for (var i = path.length - 1; i >= 0; --i) {\n    var code = path.charCodeAt(i);\n    if (code === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n    if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension\n      matchedSlash = false;\n      end = i + 1;\n    }\n    if (code === 46 /*.*/) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n    } else if (startDot !== -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension\n      preDotState = -1;\n    }\n  }\n\n  if (startDot === -1 || end === -1 ||\n      // We saw a non-dot character immediately before the dot\n      preDotState === 0 ||\n      // The (right-most) trimmed path component is exactly '..'\n      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n    return '';\n  }\n  return path.slice(startDot, end);\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n","module.exports = function (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        var x = fn(xs[i], i);\n        if (isArray(x)) res.push.apply(res, x);\n        else res.push(x);\n    }\n    return res;\n};\n\nvar isArray = Array.isArray || function (xs) {\n    return Object.prototype.toString.call(xs) === '[object Array]';\n};\n","'use strict';\nmodule.exports = balanced;\nfunction balanced(a, b, str) {\n  if (a instanceof RegExp) a = maybeMatch(a, str);\n  if (b instanceof RegExp) b = maybeMatch(b, str);\n\n  var r = range(a, b, str);\n\n  return r && {\n    start: r[0],\n    end: r[1],\n    pre: str.slice(0, r[0]),\n    body: str.slice(r[0] + a.length, r[1]),\n    post: str.slice(r[1] + b.length)\n  };\n}\n\nfunction maybeMatch(reg, str) {\n  var m = str.match(reg);\n  return m ? m[0] : null;\n}\n\nbalanced.range = range;\nfunction range(a, b, str) {\n  var begs, beg, left, right, result;\n  var ai = str.indexOf(a);\n  var bi = str.indexOf(b, ai + 1);\n  var i = ai;\n\n  if (ai >= 0 && bi > 0) {\n    begs = [];\n    left = str.length;\n\n    while (i >= 0 && !result) {\n      if (i == ai) {\n        begs.push(i);\n        ai = str.indexOf(a, i + 1);\n      } else if (begs.length == 1) {\n        result = [ begs.pop(), bi ];\n      } else {\n        beg = begs.pop();\n        if (beg < left) {\n          left = beg;\n          right = bi;\n        }\n\n        bi = str.indexOf(b, i + 1);\n      }\n\n      i = ai < bi && ai >= 0 ? ai : bi;\n    }\n\n    if (begs.length) {\n      result = [ left, right ];\n    }\n  }\n\n  return result;\n}\n","var concatMap = require('concat-map');\nvar balanced = require('balanced-match');\n\nmodule.exports = expandTop;\n\nvar escSlash = '\\0SLASH'+Math.random()+'\\0';\nvar escOpen = '\\0OPEN'+Math.random()+'\\0';\nvar escClose = '\\0CLOSE'+Math.random()+'\\0';\nvar escComma = '\\0COMMA'+Math.random()+'\\0';\nvar escPeriod = '\\0PERIOD'+Math.random()+'\\0';\n\nfunction numeric(str) {\n  return parseInt(str, 10) == str\n    ? parseInt(str, 10)\n    : str.charCodeAt(0);\n}\n\nfunction escapeBraces(str) {\n  return str.split('\\\\\\\\').join(escSlash)\n            .split('\\\\{').join(escOpen)\n            .split('\\\\}').join(escClose)\n            .split('\\\\,').join(escComma)\n            .split('\\\\.').join(escPeriod);\n}\n\nfunction unescapeBraces(str) {\n  return str.split(escSlash).join('\\\\')\n            .split(escOpen).join('{')\n            .split(escClose).join('}')\n            .split(escComma).join(',')\n            .split(escPeriod).join('.');\n}\n\n\n// Basically just str.split(\",\"), but handling cases\n// where we have nested braced sections, which should be\n// treated as individual members, like {a,{b,c},d}\nfunction parseCommaParts(str) {\n  if (!str)\n    return [''];\n\n  var parts = [];\n  var m = balanced('{', '}', str);\n\n  if (!m)\n    return str.split(',');\n\n  var pre = m.pre;\n  var body = m.body;\n  var post = m.post;\n  var p = pre.split(',');\n\n  p[p.length-1] += '{' + body + '}';\n  var postParts = parseCommaParts(post);\n  if (post.length) {\n    p[p.length-1] += postParts.shift();\n    p.push.apply(p, postParts);\n  }\n\n  parts.push.apply(parts, p);\n\n  return parts;\n}\n\nfunction expandTop(str) {\n  if (!str)\n    return [];\n\n  // I don't know why Bash 4.3 does this, but it does.\n  // Anything starting with {} will have the first two bytes preserved\n  // but *only* at the top level, so {},a}b will not expand to anything,\n  // but a{},b}c will be expanded to [a}c,abc].\n  // One could argue that this is a bug in Bash, but since the goal of\n  // this module is to match Bash's rules, we escape a leading {}\n  if (str.substr(0, 2) === '{}') {\n    str = '\\\\{\\\\}' + str.substr(2);\n  }\n\n  return expand(escapeBraces(str), true).map(unescapeBraces);\n}\n\nfunction identity(e) {\n  return e;\n}\n\nfunction embrace(str) {\n  return '{' + str + '}';\n}\nfunction isPadded(el) {\n  return /^-?0\\d/.test(el);\n}\n\nfunction lte(i, y) {\n  return i <= y;\n}\nfunction gte(i, y) {\n  return i >= y;\n}\n\nfunction expand(str, isTop) {\n  var expansions = [];\n\n  var m = balanced('{', '}', str);\n  if (!m || /\\$$/.test(m.pre)) return [str];\n\n  var isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isSequence = isNumericSequence || isAlphaSequence;\n  var isOptions = m.body.indexOf(',') >= 0;\n  if (!isSequence && !isOptions) {\n    // {a},b}\n    if (m.post.match(/,.*\\}/)) {\n      str = m.pre + '{' + m.body + escClose + m.post;\n      return expand(str);\n    }\n    return [str];\n  }\n\n  var n;\n  if (isSequence) {\n    n = m.body.split(/\\.\\./);\n  } else {\n    n = parseCommaParts(m.body);\n    if (n.length === 1) {\n      // x{{a,b}}y ==> x{a}y x{b}y\n      n = expand(n[0], false).map(embrace);\n      if (n.length === 1) {\n        var post = m.post.length\n          ? expand(m.post, false)\n          : [''];\n        return post.map(function(p) {\n          return m.pre + n[0] + p;\n        });\n      }\n    }\n  }\n\n  // at this point, n is the parts, and we know it's not a comma set\n  // with a single entry.\n\n  // no need to expand pre, since it is guaranteed to be free of brace-sets\n  var pre = m.pre;\n  var post = m.post.length\n    ? expand(m.post, false)\n    : [''];\n\n  var N;\n\n  if (isSequence) {\n    var x = numeric(n[0]);\n    var y = numeric(n[1]);\n    var width = Math.max(n[0].length, n[1].length)\n    var incr = n.length == 3\n      ? Math.abs(numeric(n[2]))\n      : 1;\n    var test = lte;\n    var reverse = y < x;\n    if (reverse) {\n      incr *= -1;\n      test = gte;\n    }\n    var pad = n.some(isPadded);\n\n    N = [];\n\n    for (var i = x; test(i, y); i += incr) {\n      var c;\n      if (isAlphaSequence) {\n        c = String.fromCharCode(i);\n        if (c === '\\\\')\n          c = '';\n      } else {\n        c = String(i);\n        if (pad) {\n          var need = width - c.length;\n          if (need > 0) {\n            var z = new Array(need + 1).join('0');\n            if (i < 0)\n              c = '-' + z + c.slice(1);\n            else\n              c = z + c;\n          }\n        }\n      }\n      N.push(c);\n    }\n  } else {\n    N = concatMap(n, function(el) { return expand(el, false) });\n  }\n\n  for (var j = 0; j < N.length; j++) {\n    for (var k = 0; k < post.length; k++) {\n      var expansion = pre + N[j] + post[k];\n      if (!isTop || isSequence || expansion)\n        expansions.push(expansion);\n    }\n  }\n\n  return expansions;\n}\n\n","module.exports = minimatch\nminimatch.Minimatch = Minimatch\n\nvar path = { sep: '/' }\ntry {\n  path = require('path')\n} catch (er) {}\n\nvar GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}\nvar expand = require('brace-expansion')\n\nvar plTypes = {\n  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},\n  '?': { open: '(?:', close: ')?' },\n  '+': { open: '(?:', close: ')+' },\n  '*': { open: '(?:', close: ')*' },\n  '@': { open: '(?:', close: ')' }\n}\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nvar qmark = '[^/]'\n\n// * => any number of characters\nvar star = qmark + '*?'\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nvar twoStarDot = '(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?'\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nvar twoStarNoDot = '(?:(?!(?:\\\\\\/|^)\\\\.).)*?'\n\n// characters that need to be escaped in RegExp.\nvar reSpecials = charSet('().*{}+?[]^$\\\\!')\n\n// \"abc\" -> { a:true, b:true, c:true }\nfunction charSet (s) {\n  return s.split('').reduce(function (set, c) {\n    set[c] = true\n    return set\n  }, {})\n}\n\n// normalizes slashes.\nvar slashSplit = /\\/+/\n\nminimatch.filter = filter\nfunction filter (pattern, options) {\n  options = options || {}\n  return function (p, i, list) {\n    return minimatch(p, pattern, options)\n  }\n}\n\nfunction ext (a, b) {\n  a = a || {}\n  b = b || {}\n  var t = {}\n  Object.keys(b).forEach(function (k) {\n    t[k] = b[k]\n  })\n  Object.keys(a).forEach(function (k) {\n    t[k] = a[k]\n  })\n  return t\n}\n\nminimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return minimatch\n\n  var orig = minimatch\n\n  var m = function minimatch (p, pattern, options) {\n    return orig.minimatch(p, pattern, ext(def, options))\n  }\n\n  m.Minimatch = function Minimatch (pattern, options) {\n    return new orig.Minimatch(pattern, ext(def, options))\n  }\n\n  return m\n}\n\nMinimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return Minimatch\n  return minimatch.defaults(def).Minimatch\n}\n\nfunction minimatch (p, pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('glob pattern string required')\n  }\n\n  if (!options) options = {}\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false\n  }\n\n  // \"\" only matches \"\"\n  if (pattern.trim() === '') return p === ''\n\n  return new Minimatch(pattern, options).match(p)\n}\n\nfunction Minimatch (pattern, options) {\n  if (!(this instanceof Minimatch)) {\n    return new Minimatch(pattern, options)\n  }\n\n  if (typeof pattern !== 'string') {\n    throw new TypeError('glob pattern string required')\n  }\n\n  if (!options) options = {}\n  pattern = pattern.trim()\n\n  // windows support: need to use /, not \\\n  if (path.sep !== '/') {\n    pattern = pattern.split(path.sep).join('/')\n  }\n\n  this.options = options\n  this.set = []\n  this.pattern = pattern\n  this.regexp = null\n  this.negate = false\n  this.comment = false\n  this.empty = false\n\n  // make the set of regexps etc.\n  this.make()\n}\n\nMinimatch.prototype.debug = function () {}\n\nMinimatch.prototype.make = make\nfunction make () {\n  // don't do it more than once.\n  if (this._made) return\n\n  var pattern = this.pattern\n  var options = this.options\n\n  // empty patterns and comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    this.comment = true\n    return\n  }\n  if (!pattern) {\n    this.empty = true\n    return\n  }\n\n  // step 1: figure out negation, etc.\n  this.parseNegate()\n\n  // step 2: expand braces\n  var set = this.globSet = this.braceExpand()\n\n  if (options.debug) this.debug = console.error\n\n  this.debug(this.pattern, set)\n\n  // step 3: now we have a set, so turn each one into a series of path-portion\n  // matching patterns.\n  // These will be regexps, except in the case of \"**\", which is\n  // set to the GLOBSTAR object for globstar behavior,\n  // and will not contain any / characters\n  set = this.globParts = set.map(function (s) {\n    return s.split(slashSplit)\n  })\n\n  this.debug(this.pattern, set)\n\n  // glob --> regexps\n  set = set.map(function (s, si, set) {\n    return s.map(this.parse, this)\n  }, this)\n\n  this.debug(this.pattern, set)\n\n  // filter out everything that didn't compile properly.\n  set = set.filter(function (s) {\n    return s.indexOf(false) === -1\n  })\n\n  this.debug(this.pattern, set)\n\n  this.set = set\n}\n\nMinimatch.prototype.parseNegate = parseNegate\nfunction parseNegate () {\n  var pattern = this.pattern\n  var negate = false\n  var options = this.options\n  var negateOffset = 0\n\n  if (options.nonegate) return\n\n  for (var i = 0, l = pattern.length\n    ; i < l && pattern.charAt(i) === '!'\n    ; i++) {\n    negate = !negate\n    negateOffset++\n  }\n\n  if (negateOffset) this.pattern = pattern.substr(negateOffset)\n  this.negate = negate\n}\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nminimatch.braceExpand = function (pattern, options) {\n  return braceExpand(pattern, options)\n}\n\nMinimatch.prototype.braceExpand = braceExpand\n\nfunction braceExpand (pattern, options) {\n  if (!options) {\n    if (this instanceof Minimatch) {\n      options = this.options\n    } else {\n      options = {}\n    }\n  }\n\n  pattern = typeof pattern === 'undefined'\n    ? this.pattern : pattern\n\n  if (typeof pattern === 'undefined') {\n    throw new TypeError('undefined pattern')\n  }\n\n  if (options.nobrace ||\n    !pattern.match(/\\{.*\\}/)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  return expand(pattern)\n}\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nMinimatch.prototype.parse = parse\nvar SUBPARSE = {}\nfunction parse (pattern, isSub) {\n  if (pattern.length > 1024 * 64) {\n    throw new TypeError('pattern is too long')\n  }\n\n  var options = this.options\n\n  // shortcuts\n  if (!options.noglobstar && pattern === '**') return GLOBSTAR\n  if (pattern === '') return ''\n\n  var re = ''\n  var hasMagic = !!options.nocase\n  var escaping = false\n  // ? => one single character\n  var patternListStack = []\n  var negativeLists = []\n  var stateChar\n  var inClass = false\n  var reClassStart = -1\n  var classStart = -1\n  // . and .. never match anything that doesn't start with .,\n  // even when options.dot is set.\n  var patternStart = pattern.charAt(0) === '.' ? '' // anything\n  // not (start or / followed by . or .. followed by / or end)\n  : options.dot ? '(?!(?:^|\\\\\\/)\\\\.{1,2}(?:$|\\\\\\/))'\n  : '(?!\\\\.)'\n  var self = this\n\n  function clearStateChar () {\n    if (stateChar) {\n      // we had some state-tracking character\n      // that wasn't consumed by this pass.\n      switch (stateChar) {\n        case '*':\n          re += star\n          hasMagic = true\n        break\n        case '?':\n          re += qmark\n          hasMagic = true\n        break\n        default:\n          re += '\\\\' + stateChar\n        break\n      }\n      self.debug('clearStateChar %j %j', stateChar, re)\n      stateChar = false\n    }\n  }\n\n  for (var i = 0, len = pattern.length, c\n    ; (i < len) && (c = pattern.charAt(i))\n    ; i++) {\n    this.debug('%s\\t%s %s %j', pattern, i, re, c)\n\n    // skip over any that are escaped.\n    if (escaping && reSpecials[c]) {\n      re += '\\\\' + c\n      escaping = false\n      continue\n    }\n\n    switch (c) {\n      case '/':\n        // completely not allowed, even escaped.\n        // Should already be path-split by now.\n        return false\n\n      case '\\\\':\n        clearStateChar()\n        escaping = true\n      continue\n\n      // the various stateChar values\n      // for the \"extglob\" stuff.\n      case '?':\n      case '*':\n      case '+':\n      case '@':\n      case '!':\n        this.debug('%s\\t%s %s %j <-- stateChar', pattern, i, re, c)\n\n        // all of those are literals inside a class, except that\n        // the glob [!a] means [^a] in regexp\n        if (inClass) {\n          this.debug('  in class')\n          if (c === '!' && i === classStart + 1) c = '^'\n          re += c\n          continue\n        }\n\n        // if we already have a stateChar, then it means\n        // that there was something like ** or +? in there.\n        // Handle the stateChar, then proceed with this one.\n        self.debug('call clearStateChar %j', stateChar)\n        clearStateChar()\n        stateChar = c\n        // if extglob is disabled, then +(asdf|foo) isn't a thing.\n        // just clear the statechar *now*, rather than even diving into\n        // the patternList stuff.\n        if (options.noext) clearStateChar()\n      continue\n\n      case '(':\n        if (inClass) {\n          re += '('\n          continue\n        }\n\n        if (!stateChar) {\n          re += '\\\\('\n          continue\n        }\n\n        patternListStack.push({\n          type: stateChar,\n          start: i - 1,\n          reStart: re.length,\n          open: plTypes[stateChar].open,\n          close: plTypes[stateChar].close\n        })\n        // negation is (?:(?!js)[^/]*)\n        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'\n        this.debug('plType %j %j', stateChar, re)\n        stateChar = false\n      continue\n\n      case ')':\n        if (inClass || !patternListStack.length) {\n          re += '\\\\)'\n          continue\n        }\n\n        clearStateChar()\n        hasMagic = true\n        var pl = patternListStack.pop()\n        // negation is (?:(?!js)[^/]*)\n        // The others are (?:<pattern>)<type>\n        re += pl.close\n        if (pl.type === '!') {\n          negativeLists.push(pl)\n        }\n        pl.reEnd = re.length\n      continue\n\n      case '|':\n        if (inClass || !patternListStack.length || escaping) {\n          re += '\\\\|'\n          escaping = false\n          continue\n        }\n\n        clearStateChar()\n        re += '|'\n      continue\n\n      // these are mostly the same in regexp and glob\n      case '[':\n        // swallow any state-tracking char before the [\n        clearStateChar()\n\n        if (inClass) {\n          re += '\\\\' + c\n          continue\n        }\n\n        inClass = true\n        classStart = i\n        reClassStart = re.length\n        re += c\n      continue\n\n      case ']':\n        //  a right bracket shall lose its special\n        //  meaning and represent itself in\n        //  a bracket expression if it occurs\n        //  first in the list.  -- POSIX.2 2.8.3.2\n        if (i === classStart + 1 || !inClass) {\n          re += '\\\\' + c\n          escaping = false\n          continue\n        }\n\n        // handle the case where we left a class open.\n        // \"[z-a]\" is valid, equivalent to \"\\[z-a\\]\"\n        if (inClass) {\n          // split where the last [ was, make sure we don't have\n          // an invalid re. if so, re-walk the contents of the\n          // would-be class to re-translate any characters that\n          // were passed through as-is\n          // TODO: It would probably be faster to determine this\n          // without a try/catch and a new RegExp, but it's tricky\n          // to do safely.  For now, this is safe and works.\n          var cs = pattern.substring(classStart + 1, i)\n          try {\n            RegExp('[' + cs + ']')\n          } catch (er) {\n            // not a valid class!\n            var sp = this.parse(cs, SUBPARSE)\n            re = re.substr(0, reClassStart) + '\\\\[' + sp[0] + '\\\\]'\n            hasMagic = hasMagic || sp[1]\n            inClass = false\n            continue\n          }\n        }\n\n        // finish up the class.\n        hasMagic = true\n        inClass = false\n        re += c\n      continue\n\n      default:\n        // swallow any state char that wasn't consumed\n        clearStateChar()\n\n        if (escaping) {\n          // no need\n          escaping = false\n        } else if (reSpecials[c]\n          && !(c === '^' && inClass)) {\n          re += '\\\\'\n        }\n\n        re += c\n\n    } // switch\n  } // for\n\n  // handle the case where we left a class open.\n  // \"[abc\" is valid, equivalent to \"\\[abc\"\n  if (inClass) {\n    // split where the last [ was, and escape it\n    // this is a huge pita.  We now have to re-walk\n    // the contents of the would-be class to re-translate\n    // any characters that were passed through as-is\n    cs = pattern.substr(classStart + 1)\n    sp = this.parse(cs, SUBPARSE)\n    re = re.substr(0, reClassStart) + '\\\\[' + sp[0]\n    hasMagic = hasMagic || sp[1]\n  }\n\n  // handle the case where we had a +( thing at the *end*\n  // of the pattern.\n  // each pattern list stack adds 3 chars, and we need to go through\n  // and escape any | chars that were passed through as-is for the regexp.\n  // Go through and escape them, taking care not to double-escape any\n  // | chars that were already escaped.\n  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {\n    var tail = re.slice(pl.reStart + pl.open.length)\n    this.debug('setting tail', re, pl)\n    // maybe some even number of \\, then maybe 1 \\, followed by a |\n    tail = tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g, function (_, $1, $2) {\n      if (!$2) {\n        // the | isn't already escaped, so escape it.\n        $2 = '\\\\'\n      }\n\n      // need to escape all those slashes *again*, without escaping the\n      // one that we need for escaping the | character.  As it works out,\n      // escaping an even number of slashes can be done by simply repeating\n      // it exactly after itself.  That's why this trick works.\n      //\n      // I am sorry that you have to see this.\n      return $1 + $1 + $2 + '|'\n    })\n\n    this.debug('tail=%j\\n   %s', tail, tail, pl, re)\n    var t = pl.type === '*' ? star\n      : pl.type === '?' ? qmark\n      : '\\\\' + pl.type\n\n    hasMagic = true\n    re = re.slice(0, pl.reStart) + t + '\\\\(' + tail\n  }\n\n  // handle trailing things that only matter at the very end.\n  clearStateChar()\n  if (escaping) {\n    // trailing \\\\\n    re += '\\\\\\\\'\n  }\n\n  // only need to apply the nodot start if the re starts with\n  // something that could conceivably capture a dot\n  var addPatternStart = false\n  switch (re.charAt(0)) {\n    case '.':\n    case '[':\n    case '(': addPatternStart = true\n  }\n\n  // Hack to work around lack of negative lookbehind in JS\n  // A pattern like: *.!(x).!(y|z) needs to ensure that a name\n  // like 'a.xyz.yz' doesn't match.  So, the first negative\n  // lookahead, has to look ALL the way ahead, to the end of\n  // the pattern.\n  for (var n = negativeLists.length - 1; n > -1; n--) {\n    var nl = negativeLists[n]\n\n    var nlBefore = re.slice(0, nl.reStart)\n    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)\n    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)\n    var nlAfter = re.slice(nl.reEnd)\n\n    nlLast += nlAfter\n\n    // Handle nested stuff like *(*.js|!(*.json)), where open parens\n    // mean that we should *not* include the ) in the bit that is considered\n    // \"after\" the negated section.\n    var openParensBefore = nlBefore.split('(').length - 1\n    var cleanAfter = nlAfter\n    for (i = 0; i < openParensBefore; i++) {\n      cleanAfter = cleanAfter.replace(/\\)[+*?]?/, '')\n    }\n    nlAfter = cleanAfter\n\n    var dollar = ''\n    if (nlAfter === '' && isSub !== SUBPARSE) {\n      dollar = '$'\n    }\n    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast\n    re = newRe\n  }\n\n  // if the re is not \"\" at this point, then we need to make sure\n  // it doesn't match against an empty path part.\n  // Otherwise a/* will match a/, which it should not.\n  if (re !== '' && hasMagic) {\n    re = '(?=.)' + re\n  }\n\n  if (addPatternStart) {\n    re = patternStart + re\n  }\n\n  // parsing just a piece of a larger pattern.\n  if (isSub === SUBPARSE) {\n    return [re, hasMagic]\n  }\n\n  // skip the regexp for non-magical patterns\n  // unescape anything in it, though, so that it'll be\n  // an exact match against a file etc.\n  if (!hasMagic) {\n    return globUnescape(pattern)\n  }\n\n  var flags = options.nocase ? 'i' : ''\n  try {\n    var regExp = new RegExp('^' + re + '$', flags)\n  } catch (er) {\n    // If it was an invalid regular expression, then it can't match\n    // anything.  This trick looks for a character after the end of\n    // the string, which is of course impossible, except in multi-line\n    // mode, but it's not a /m regex.\n    return new RegExp('$.')\n  }\n\n  regExp._glob = pattern\n  regExp._src = re\n\n  return regExp\n}\n\nminimatch.makeRe = function (pattern, options) {\n  return new Minimatch(pattern, options || {}).makeRe()\n}\n\nMinimatch.prototype.makeRe = makeRe\nfunction makeRe () {\n  if (this.regexp || this.regexp === false) return this.regexp\n\n  // at this point, this.set is a 2d array of partial\n  // pattern strings, or \"**\".\n  //\n  // It's better to use .match().  This function shouldn't\n  // be used, really, but it's pretty convenient sometimes,\n  // when you just want to work with a regex.\n  var set = this.set\n\n  if (!set.length) {\n    this.regexp = false\n    return this.regexp\n  }\n  var options = this.options\n\n  var twoStar = options.noglobstar ? star\n    : options.dot ? twoStarDot\n    : twoStarNoDot\n  var flags = options.nocase ? 'i' : ''\n\n  var re = set.map(function (pattern) {\n    return pattern.map(function (p) {\n      return (p === GLOBSTAR) ? twoStar\n      : (typeof p === 'string') ? regExpEscape(p)\n      : p._src\n    }).join('\\\\\\/')\n  }).join('|')\n\n  // must match entire pattern\n  // ending in a * or ** will make it less strict.\n  re = '^(?:' + re + ')$'\n\n  // can match anything, as long as it's not this.\n  if (this.negate) re = '^(?!' + re + ').*$'\n\n  try {\n    this.regexp = new RegExp(re, flags)\n  } catch (ex) {\n    this.regexp = false\n  }\n  return this.regexp\n}\n\nminimatch.match = function (list, pattern, options) {\n  options = options || {}\n  var mm = new Minimatch(pattern, options)\n  list = list.filter(function (f) {\n    return mm.match(f)\n  })\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\n\nMinimatch.prototype.match = match\nfunction match (f, partial) {\n  this.debug('match', f, this.pattern)\n  // short-circuit in the case of busted things.\n  // comments, etc.\n  if (this.comment) return false\n  if (this.empty) return f === ''\n\n  if (f === '/' && partial) return true\n\n  var options = this.options\n\n  // windows: need to use /, not \\\n  if (path.sep !== '/') {\n    f = f.split(path.sep).join('/')\n  }\n\n  // treat the test path as a set of pathparts.\n  f = f.split(slashSplit)\n  this.debug(this.pattern, 'split', f)\n\n  // just ONE of the pattern sets in this.set needs to match\n  // in order for it to be valid.  If negating, then just one\n  // match means that we have failed.\n  // Either way, return on the first hit.\n\n  var set = this.set\n  this.debug(this.pattern, 'set', set)\n\n  // Find the basename of the path by looking for the last non-empty segment\n  var filename\n  var i\n  for (i = f.length - 1; i >= 0; i--) {\n    filename = f[i]\n    if (filename) break\n  }\n\n  for (i = 0; i < set.length; i++) {\n    var pattern = set[i]\n    var file = f\n    if (options.matchBase && pattern.length === 1) {\n      file = [filename]\n    }\n    var hit = this.matchOne(file, pattern, partial)\n    if (hit) {\n      if (options.flipNegate) return true\n      return !this.negate\n    }\n  }\n\n  // didn't get any hits.  this is success if it's a negative\n  // pattern, failure otherwise.\n  if (options.flipNegate) return false\n  return this.negate\n}\n\n// set partial to true to test if, for example,\n// \"/a/b\" matches the start of \"/*/b/*/d\"\n// Partial means, if you run out of file before you run\n// out of pattern, then that's fine, as long as all\n// the parts match.\nMinimatch.prototype.matchOne = function (file, pattern, partial) {\n  var options = this.options\n\n  this.debug('matchOne',\n    { 'this': this, file: file, pattern: pattern })\n\n  this.debug('matchOne', file.length, pattern.length)\n\n  for (var fi = 0,\n      pi = 0,\n      fl = file.length,\n      pl = pattern.length\n      ; (fi < fl) && (pi < pl)\n      ; fi++, pi++) {\n    this.debug('matchOne loop')\n    var p = pattern[pi]\n    var f = file[fi]\n\n    this.debug(pattern, p, f)\n\n    // should be impossible.\n    // some invalid regexp stuff in the set.\n    if (p === false) return false\n\n    if (p === GLOBSTAR) {\n      this.debug('GLOBSTAR', [pattern, p, f])\n\n      // \"**\"\n      // a/**/b/**/c would match the following:\n      // a/b/x/y/z/c\n      // a/x/y/z/b/c\n      // a/b/x/b/x/c\n      // a/b/c\n      // To do this, take the rest of the pattern after\n      // the **, and see if it would match the file remainder.\n      // If so, return success.\n      // If not, the ** \"swallows\" a segment, and try again.\n      // This is recursively awful.\n      //\n      // a/**/b/**/c matching a/b/x/y/z/c\n      // - a matches a\n      // - doublestar\n      //   - matchOne(b/x/y/z/c, b/**/c)\n      //     - b matches b\n      //     - doublestar\n      //       - matchOne(x/y/z/c, c) -> no\n      //       - matchOne(y/z/c, c) -> no\n      //       - matchOne(z/c, c) -> no\n      //       - matchOne(c, c) yes, hit\n      var fr = fi\n      var pr = pi + 1\n      if (pr === pl) {\n        this.debug('** at the end')\n        // a ** at the end will just swallow the rest.\n        // We have found a match.\n        // however, it will not swallow /.x, unless\n        // options.dot is set.\n        // . and .. are *never* matched by **, for explosively\n        // exponential reasons.\n        for (; fi < fl; fi++) {\n          if (file[fi] === '.' || file[fi] === '..' ||\n            (!options.dot && file[fi].charAt(0) === '.')) return false\n        }\n        return true\n      }\n\n      // ok, let's see if we can swallow whatever we can.\n      while (fr < fl) {\n        var swallowee = file[fr]\n\n        this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee)\n\n        // XXX remove this slice.  Just pass the start index.\n        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n          this.debug('globstar found match!', fr, fl, swallowee)\n          // found a match.\n          return true\n        } else {\n          // can't swallow \".\" or \"..\" ever.\n          // can only swallow \".foo\" when explicitly asked.\n          if (swallowee === '.' || swallowee === '..' ||\n            (!options.dot && swallowee.charAt(0) === '.')) {\n            this.debug('dot detected!', file, fr, pattern, pr)\n            break\n          }\n\n          // ** swallows a segment, and continue.\n          this.debug('globstar swallow a segment, and continue')\n          fr++\n        }\n      }\n\n      // no match was found.\n      // However, in partial mode, we can't say this is necessarily over.\n      // If there's more *pattern* left, then\n      if (partial) {\n        // ran out of file\n        this.debug('\\n>>> no match, partial?', file, fr, pattern, pr)\n        if (fr === fl) return true\n      }\n      return false\n    }\n\n    // something other than **\n    // non-magic patterns just have to match exactly\n    // patterns with magic have been turned into regexps.\n    var hit\n    if (typeof p === 'string') {\n      if (options.nocase) {\n        hit = f.toLowerCase() === p.toLowerCase()\n      } else {\n        hit = f === p\n      }\n      this.debug('string match', p, f, hit)\n    } else {\n      hit = f.match(p)\n      this.debug('pattern match', p, f, hit)\n    }\n\n    if (!hit) return false\n  }\n\n  // Note: ending in / means that we'll get a final \"\"\n  // at the end of the pattern.  This can only match a\n  // corresponding \"\" at the end of the file.\n  // If the file ends in /, then it can only match a\n  // a pattern that ends in /, unless the pattern just\n  // doesn't have any more for it. But, a/b/ should *not*\n  // match \"a/b/*\", even though \"\" matches against the\n  // [^/]*? pattern, except in partial mode, where it might\n  // simply not be reached yet.\n  // However, a/b/ should still satisfy a/*\n\n  // now either we fell off the end of the pattern, or we're done.\n  if (fi === fl && pi === pl) {\n    // ran out of pattern and filename at the same time.\n    // an exact hit!\n    return true\n  } else if (fi === fl) {\n    // ran out of file, but still had pattern left.\n    // this is ok if we're doing the match as part of\n    // a glob fs traversal.\n    return partial\n  } else if (pi === pl) {\n    // ran out of pattern, still have file left.\n    // this is only acceptable if we're on the very last\n    // empty segment of a file with a trailing slash.\n    // a/* should match a/b/\n    var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')\n    return emptyFileEnd\n  }\n\n  // should be unreachable.\n  throw new Error('wtf?')\n}\n\n// replace stuff like \\* with *\nfunction globUnescape (s) {\n  return s.replace(/\\\\(.)/g, '$1')\n}\n\nfunction regExpEscape (s) {\n  return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n}\n","\nexport enum Versions {\n\tV0_0_1 = \"0.0.1\",\n\tV0_1_0 = \"0.1.0\",\n\tV0_2 = \"0.2\",\n\tV0_3 = \"0.3\"\n  }\n\nexport const AllVersions = Object.keys(Versions);\n\nexport const CurrentVersion = Versions.V0_3;\n","import {AllVersions} from \"./MetaLibsVersion\";\n\nexport const METAFRAME_JSON_FILE = \"metaframe.json\";\nexport const METAPAGE_KEY_DEFINITION = \"metapage/definition\";\nexport const METAPAGE_KEY_STATE = \"metapage/state\";\nexport const URL_PARAM_DEBUG = \"MP_DEBUG\";\n\nexport const VERSION = AllVersions[AllVersions.length - 1];\n","import {MetaframeId, MetapageId, MetaframeInputMap, Versions} from \"./all\";\nimport {JsonRpcRequest} from '../jsonrpc2';\n\n\nexport enum JsonRpcMethodsFromChild {\n  InputsUpdate = \"InputsUpdate\",\n  OutputsUpdate = \"OutputsUpdate\",\n  SetupIframeClientRequest = \"SetupIframeClientRequest\",\n  SetupIframeServerResponseAck = \"SetupIframeServerResponseAck\",\n  // Plugin API\n  PluginRequest = \"SetupIframeServerPluginRequestResponseAck\" // See further definitions: ApiPayloadPluginRequest*\n}\n\nexport enum JsonRpcMethodsFromParent {\n  InputsUpdate = \"InputsUpdate\",\n  MessageAck = \"MessageAck\",\n  SetupIframeServerResponse = \"SetupIframeServerResponse\"\n}\n\nexport enum OtherEvents {\n  Message = \"Message\"\n}\n\nexport interface SetupIframeServerResponseData {\n  iframeId: MetaframeId;\n  parentId: MetapageId;\n  state: {\n    inputs: MetaframeInputMap\n  };\n  // Allow newer metaframes to handle older metapage versions\n  version: Versions;\n  //is this metaframe a plugin?\n  plugin: boolean;\n}\n\nexport interface MinimumClientMessage<T> extends JsonRpcRequest<T> {\n  iframeId: MetaframeId | undefined;\n  parentId: MetapageId | undefined;\n}\n\nexport interface SetupIframeClientAckData<T> extends MinimumClientMessage<T> {\n  version: Versions;\n}\n\nexport interface ClientMessageRecievedAck<T> {\n  message: MinimumClientMessage<T>;\n}\n\n// Plugin API definitions\nexport enum ApiPayloadPluginRequestMethod {\n  State = \"metapage/state\"\n}\n\nexport interface ApiPayloadPluginRequest {\n  method: ApiPayloadPluginRequestMethod;\n}\n","/* global define */\n(function (root, factory) {\n  /* istanbul ignore next */\n  if (typeof define === 'function' && define.amd) {\n    define([], factory);\n  } else if (typeof exports === 'object') {\n    module.exports = factory();\n  } else {\n    root.compareVersions = factory();\n  }\n}(this, function () {\n\n  var semver = /^v?(?:\\d+)(\\.(?:[x*]|\\d+)(\\.(?:[x*]|\\d+)(\\.(?:[x*]|\\d+))?(?:-[\\da-z\\-]+(?:\\.[\\da-z\\-]+)*)?(?:\\+[\\da-z\\-]+(?:\\.[\\da-z\\-]+)*)?)?)?$/i;\n\n  function indexOrEnd(str, q) {\n    return str.indexOf(q) === -1 ? str.length : str.indexOf(q);\n  }\n\n  function split(v) {\n    var c = v.replace(/^v/, '').replace(/\\+.*$/, '');\n    var patchIndex = indexOrEnd(c, '-');\n    var arr = c.substring(0, patchIndex).split('.');\n    arr.push(c.substring(patchIndex + 1));\n    return arr;\n  }\n\n  function tryParse(v) {\n    return isNaN(Number(v)) ? v : Number(v);\n  }\n\n  function validate(version) {\n    if (typeof version !== 'string') {\n      throw new TypeError('Invalid argument expected string');\n    }\n    if (!semver.test(version)) {\n      throw new Error('Invalid argument not valid semver (\\''+version+'\\' received)');\n    }\n  }\n\n  function compareVersions(v1, v2) {\n    [v1, v2].forEach(validate);\n\n    var s1 = split(v1);\n    var s2 = split(v2);\n\n    for (var i = 0; i < Math.max(s1.length - 1, s2.length - 1); i++) {\n      var n1 = parseInt(s1[i] || 0, 10);\n      var n2 = parseInt(s2[i] || 0, 10);\n\n      if (n1 > n2) return 1;\n      if (n2 > n1) return -1;\n    }\n\n    var sp1 = s1[s1.length - 1];\n    var sp2 = s2[s2.length - 1];\n\n    if (sp1 && sp2) {\n      var p1 = sp1.split('.').map(tryParse);\n      var p2 = sp2.split('.').map(tryParse);\n\n      for (i = 0; i < Math.max(p1.length, p2.length); i++) {\n        if (p1[i] === undefined || typeof p2[i] === 'string' && typeof p1[i] === 'number') return -1;\n        if (p2[i] === undefined || typeof p1[i] === 'string' && typeof p2[i] === 'number') return 1;\n\n        if (p1[i] > p2[i]) return 1;\n        if (p2[i] > p1[i]) return -1;\n      }\n    } else if (sp1 || sp2) {\n      return sp1 ? -1 : 1;\n    }\n\n    return 0;\n  };\n\n  var allowedOperators = [\n    '>',\n    '>=',\n    '=',\n    '<',\n    '<='\n  ];\n\n  var operatorResMap = {\n    '>': [1],\n    '>=': [0, 1],\n    '=': [0],\n    '<=': [-1, 0],\n    '<': [-1]\n  };\n\n  function validateOperator(op) {\n    if (typeof op !== 'string') {\n      throw new TypeError('Invalid operator type, expected string but got ' + typeof op);\n    }\n    if (allowedOperators.indexOf(op) === -1) {\n      throw new TypeError('Invalid operator, expected one of ' + allowedOperators.join('|'));\n    }\n  }\n\n  compareVersions.validate = function(version) {\n    return typeof version === 'string' && semver.test(version);\n  }\n\n  compareVersions.compare = function (v1, v2, operator) {\n    // Validate operator\n    validateOperator(operator);\n\n    // since result of compareVersions can only be -1 or 0 or 1\n    // a simple map can be used to replace switch\n    var res = compareVersions(v1, v2);\n    return operatorResMap[operator].indexOf(res) > -1;\n  }\n\n  return compareVersions;\n}));\n","import {compare} from \"compare-versions\";\nimport {URL_PARAM_DEBUG} from \"./Constants\";\nimport {Versions, AllVersions, CurrentVersion} from \"./MetaLibsVersion\";\nimport {MetaframeInputMap, MetaframeId, MetapageId, MetapageDefinition} from \"./v0_3/all\";\n\nimport {MetapageDefinition as V0_2MetapageDefinition} from \"./v0_2/all\";\nimport {MetapageDefinition as V0_3MetapageDefinition} from \"./v0_3/all\";\n\n// metapages can convert any past version to the current version.\nexport const convertToCurrentDefinition = (def : any): MetapageDefinition => {\n  if (def === null) {\n    throw \"Metapage definition cannot be null\";\n  }\n  if (typeof def === \"string\") {\n    try {\n      def = JSON.parse(def);\n    } catch (err) {\n      throw `Cannot parse into JSON:\\n${def}`;\n    }\n  }\n\n  // Recursively convert up the version\n  let updatedDefinition: MetapageDefinition;\n  switch (getMatchingVersion(def.version)) {\n    case Versions.V0_2:\n      {\n        updatedDefinition = convertToCurrentDefinition(definition_v0_2_to_v0_3(def as V0_2MetapageDefinition));\n        break;\n      }\n    case Versions.V0_3:\n      {\n        updatedDefinition = def as MetapageDefinition; // Latest\n        break;\n      }\n    default:\n      {\n        throw `Unknown metapage version: ${\n        def.version}. Supported versions: [${AllVersions.join(\", \")}]`;\n      }\n  }\n  return updatedDefinition;\n};\n\nconst definition_v0_2_to_v0_3 = (old : V0_2MetapageDefinition): V0_3MetapageDefinition => {\n  // Exactly the same except v0.3 has plugins\n  old.version = Versions.V0_3;\n  return old;\n};\n\n/**\n * Merges new values into the current object.\n * Does NOT check if there are actually new keys.\n * Does NOT check values against each other. This means you\n * can keep sending the same value, and the message will\n * be passed in.\n * Returns true if the original map was modified.\n */\nexport const merge = (current : MetaframeInputMap, newInputs : MetaframeInputMap): boolean => {\n  if (!newInputs) {\n    return false;\n  }\n  let modified = false;\n  Object.keys(newInputs).forEach((pipeId : string) => {\n    modified = true;\n    // undefined means remove the key\n    // null means keep the key, but set to null\n    if (newInputs[pipeId] === undefined) {\n      delete current[pipeId];\n    } else {\n      current[pipeId] = newInputs[pipeId];\n    }\n  });\n  return modified;\n};\n\nexport const getMatchingVersion = (version : string): Versions => {\n  if (version == \"latest\") {\n    return CurrentVersion;\n  } else if (compare(version, \"0.0.x\", \"<\")) {\n    return Versions.V0_0_1;\n  } else if (compare(version, \"0.1.36\", \">=\") && compare(version, Versions.V0_2, \"<\")) {\n    return Versions.V0_1_0;\n  } else if (compare(version, \"0.2\", \">=\") && compare(version, Versions.V0_3, \"<\")) {\n    return Versions.V0_2;\n  } else if (compare(version, \"0.3\", \">=\")) {\n    return Versions.V0_3;\n  } else {\n    // Return something, assume latest\n    console.log(`Could not match version=${version} to any known version, assuming ${CurrentVersion}`);\n    return CurrentVersion;\n  }\n};\n\nexport const getUrlParam = (key : string): string | null => {\n  if (!window.location.search) {\n    return null;\n  }\n  return new URLSearchParams(window.location.search).get(key);\n};\n\nexport const getUrlParamDEBUG = (): boolean => {\n  return new URLSearchParams(window.location.search).has(URL_PARAM_DEBUG);\n};\n\nexport const existsAnyUrlParam = (k : string[]): boolean => {\n  const members = k.filter((param : string) => {\n    return new URLSearchParams(window.location.search).has(param);\n  });\n  return members.length > 0;\n};\n\nexport const generateMetaframeId = (length : number = 8): MetaframeId => {\n  return generateId(length);\n};\n\nexport const generateMetapageId = (length : number = 8): MetapageId => {\n  return generateId(length);\n};\n\nexport const generateNonce = (length : number = 8): string => {\n  return generateId(length);\n};\n\nconst LETTERS = \"abcdefghijklmnopqrstuvwxyz0123456789\";\nexport const generateId = (length : number = 8): string => {\n  var result = \"\";\n  var characters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n  var charactersLength = LETTERS.length;\n  for (var i = 0; i < length; i++) {\n    result += LETTERS.charAt(Math.floor(Math.random() * charactersLength));\n  }\n  return result;\n};\n\nexport const log = (o : any, color? : string, backgroundColor? : string) => {\n  color = color\n    ? color\n    : \"000\";\n  if (color && color.trim() == \"\") {\n    color = undefined;\n  }\n  let s: string;\n  if (typeof o === \"string\") {\n    s = o as string;\n  } else if (typeof o === \"number\") {\n    s = o + \"\";\n  } else {\n    s = JSON.stringify(o, null, \"  \");\n  }\n\n  if (color && color.trim() != \"\") {\n    var cssstring = `color: #${color}`;\n    if (backgroundColor) {\n      cssstring = `${cssstring}; background: #${backgroundColor}`;\n    }\n    s = `%c${s}`;\n    window.console.log(s, cssstring);\n  } else {\n    window.console.log(s);\n  }\n};\n\nexport const stringToRgb = (str : string): string => {\n  return intToRGB(hashCode(str));\n};\n\nexport const hashCode = (str : string): number => {\n  // java string#hashCode\n  var hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    hash = str.charCodeAt(i) + ((hash << 5) - hash);\n  }\n  return hash;\n};\n\nexport const intToRGB = (i : number): string => {\n  var c = (i & 0x00ffffff).toString(16).toUpperCase();\n  return \"00000\".substring(0, 6 - c.length) + c;\n};\n\n/*\n * base64-arraybuffer\n * https://github.com/niklasvh/base64-arraybuffer\n *\n * Copyright (c) 2012 Niklas von Hertzen\n * Licensed under the MIT license.\n */\n\nconst chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n// Use a lookup table to find the index.\nconst lookup = new Uint8Array(256);\nfor (var i = 0; i < chars.length; i++) {\n  lookup[chars.charCodeAt(i)] = i;\n}\n\nexport function base64encode(arraybuffer : ArrayBuffer) :string {\n  let bytes = new Uint8Array(arraybuffer);\n  let i: number;\n  let len = bytes.length;\n  let base64 = \"\";\n\n  for (i = 0; i < len; i += 3) {\n    base64 += chars[bytes[i] >> 2];\n    base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n    base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n    base64 += chars[bytes[i + 2] & 63];\n  }\n\n  if (len % 3 === 2) {\n    base64 = base64.substring(0, base64.length - 1) + \"=\";\n  } else if (len % 3 === 1) {\n    base64 = base64.substring(0, base64.length - 2) + \"==\";\n  }\n\n  return base64;\n}\n\nexport function base64decode(base64 : string) :ArrayBuffer {\n    if (!base64) {\n        throw new Error(\"base64decode string argument given\");\n    }\n  let bufferLength = base64.length * 0.75,\n    len = base64.length,\n    i:number,\n    p = 0,\n    encoded1: number,\n    encoded2: number,\n    encoded3: number,\n    encoded4: number;\n\n  if (base64[base64.length - 1] === \"=\") {\n    bufferLength--;\n    if (base64[base64.length - 2] === \"=\") {\n      bufferLength--;\n    }\n  }\n\n  var arraybuffer = new ArrayBuffer(bufferLength),\n    bytes = new Uint8Array(arraybuffer);\n\n  for (i = 0; i < len; i += 4) {\n    encoded1 = lookup[base64.charCodeAt(i)];\n    encoded2 = lookup[base64.charCodeAt(i + 1)];\n    encoded3 = lookup[base64.charCodeAt(i + 2)];\n    encoded4 = lookup[base64.charCodeAt(i + 3)];\n\n    bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n    bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n    bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n  }\n\n  return arraybuffer;\n}\n","import {EventEmitter, ListenerFn} from \"eventemitter3\";\nimport minimatch from \"minimatch\";\nimport {URL_PARAM_DEBUG, VERSION, METAPAGE_KEY_STATE, METAPAGE_KEY_DEFINITION} from \"./Constants\";\nimport {Versions} from \"./MetaLibsVersion\";\nimport {\n  MetaframeDefinition,\n  MetaframeInstance,\n  PipeInput,\n  MetapageOptions,\n  MetaframeInputMap,\n  MetaframePipeId,\n  MetaframeId,\n  MetapageId,\n  MetapageInstanceInputs,\n  MetapageDefinition\n} from \"./v0_3/all\";\nimport {\n  JsonRpcMethodsFromParent,\n  JsonRpcMethodsFromChild,\n  SetupIframeServerResponseData,\n  MinimumClientMessage,\n  SetupIframeClientAckData,\n  OtherEvents,\n  ClientMessageRecievedAck\n} from \"./v0_3/JsonRpcMethods\";\nimport {\n  stringToRgb,\n  log as MetapageToolsLog,\n  getMatchingVersion,\n  generateMetapageId,\n  existsAnyUrlParam,\n  convertToCurrentDefinition,\n  merge\n} from \"./MetapageTools\";\nimport {JsonRpcRequest} from \"./jsonrpc2\";\n\nexport enum MetapageEvents {\n  Inputs = \"inputs\",\n  Outputs = \"outputs\",\n  State = \"state\",\n  Definition = \"definition\",\n  Error = \"error\"\n}\n\nexport enum MetapageEventStateType {\n  all = \"all\",\n  delta = \"delta\"\n}\n\nexport interface MetapageEventDefinition {\n  definition: MetapageDefinition;\n  metaframes: {\n    [key: string]: IFrameRpcClient;\n  };\n  plugins?: {\n    [key: string]: IFrameRpcClient;\n  };\n}\n\ninterface MetapageStatePartial {\n  inputs: MetapageInstanceInputs;\n  outputs: MetapageInstanceInputs;\n}\n\nexport interface MetapageState {\n  metaframes: MetapageStatePartial;\n  plugins: MetapageStatePartial;\n}\n\ntype Url = string;\n// type Listener = (a1? : any, a2? : any) => void;\n\nconst emptyState = (): MetapageState => {\n  return {\n    metaframes: {\n      inputs: {},\n      outputs: {}\n    },\n    plugins: {\n      inputs: {},\n      outputs: {}\n    }\n  };\n};\nexport const getLibraryVersionMatching = (version : string): Versions => {\n  return getMatchingVersion(version);\n};\n\n\ntype MetaframeInputTargetsFromOutput = {\n  metaframe: MetaframeId;\n  pipe: MetaframePipeId;\n}\n\nconst CONSOLE_BACKGROUND_COLOR_DEFAULT = \"bcbcbc\";\n\nexport class Metapage extends EventEmitter < MetapageEvents | JsonRpcMethodsFromParent | OtherEvents > {\n  // The current version is always the latest\n  public static readonly version = VERSION;\n\n  // Event literals for users to listen to events\n  public static readonly DEFINITION = MetapageEvents.Definition;\n  public static readonly INPUTS = MetapageEvents.Inputs;\n  public static readonly OUTPUTS = MetapageEvents.Outputs;\n  public static readonly STATE = MetapageEvents.State;\n  public static readonly ERROR = MetapageEvents.Error;\n\n  public static from(metaPageDef : any, inputs? : any): Metapage {\n    if (metaPageDef == null) {\n      throw \"Metapage definition cannot be null\";\n    }\n    if (typeof metaPageDef === \"string\") {\n      try {\n        metaPageDef = JSON.parse(metaPageDef);\n      } catch (err) {\n        throw \"Cannot parse into JSON:\\n${metaPageDef}\";\n      }\n    }\n\n    var metapage = new Metapage();\n    return metapage.setDefinition(metaPageDef);\n  }\n\n  _id: MetapageId;\n  _definition: MetapageDefinition | undefined;\n  _state: MetapageState = emptyState();\n  _metaframes: {\n    [key: string]: IFrameRpcClient;\n  } = {}; //<MetaframeId, IFrameRpcClient>\n  _plugins: {\n    [key: string]: IFrameRpcClient;\n  } = {}; // <Url, IFrameRpcClient>\n  _pluginOrder: Url[] = [];\n\n  debug: boolean = false;\n  _consoleBackgroundColor: string;\n\n  // for caching input lookups\n  _cachedInputLookupMap: {\n    [key: string]: { // metaframeId\n      [key: string]: MetaframeInputTargetsFromOutput[]; // <metaframeId, MetaframeInputTargetsFromOutput[]>\n    };\n  } = {};\n  _inputMap: {\n    [key: string]: PipeInput[];\n  } = {};\n  // Example:\n  // \t{\n  //     \"version\": \"0.1.0\",\n  //     \"metaframes\": {\n  //       \"metaframe1\": {\n  //         \"url\": \"{{site.baseurl}}/metaframes/example00_iframe1/\",\n  //         \"inputs\": [\n  //           {\n  //             \"metaframe\":\"metaframe2\",\n  //             \"source\": \"barOut\",\n  //             \"target\": \"barIn\",\n  //           }\n  //         ]\n  //       },\n  //       \"metaframe2\": {\n  //         \"url\": \"{{site.baseurl}}/metaframes/example00_iframe2/\",\n  //         \"inputs\": [\n  //           {\n  //             \"metaframe\":\"metaframe1\",\n  //             \"source\": \"fooOut\",\n  //             \"target\": \"fooIn\",\n  //           }\n  //         ]\n  //       }\n  //     }\n  // }\n\n  constructor(opts? : MetapageOptions) {\n    super();\n    this._id = opts && opts.id\n      ? opts.id\n      : generateMetapageId();\n    this._consoleBackgroundColor = opts && opts.color\n      ? opts.color\n      : CONSOLE_BACKGROUND_COLOR_DEFAULT;\n\n    this.addPipe = this.addPipe.bind(this);\n    this.dispose = this.dispose.bind(this);\n    this.getDefinition = this.getDefinition.bind(this);\n    this.addMetaframe = this.addMetaframe.bind(this);\n    this.addPlugin = this.addPlugin.bind(this);\n    this.getInputsFromOutput = this.getInputsFromOutput.bind(this);\n    this.getMetaframe = this.getMetaframe.bind(this);\n    this.getMetaframeIds = this.getMetaframeIds.bind(this);\n    this.getMetaframeOrPlugin = this.getMetaframeOrPlugin.bind(this);\n    this.getMetaframes = this.getMetaframes.bind(this);\n    this.getPlugin = this.getPlugin.bind(this);\n    this.getPluginIds = this.getPluginIds.bind(this);\n    this.getState = this.getState.bind(this);\n    this.getStateMetaframes = this.getStateMetaframes.bind(this);\n    this.isValidJSONRpcMessage = this.isValidJSONRpcMessage.bind(this);\n    this.log = this.log.bind(this);\n    this.logInternal = this.logInternal.bind(this);\n    this.metaframeIds = this.metaframeIds.bind(this);\n    this.metaframes = this.metaframes.bind(this);\n    this.onMessage = this.onMessage.bind(this);\n    // this.onState = this.onState.bind(this);\n    this.pluginIds = this.pluginIds.bind(this);\n    this.plugins = this.plugins.bind(this);\n    this.removeAll = this.removeAll.bind(this);\n    this.removeMetaframe = this.removeMetaframe.bind(this);\n    this.removePlugin = this.removePlugin.bind(this);\n    this.setDebugFromUrlParams = this.setDebugFromUrlParams.bind(this);\n    this.setDefinition = this.setDefinition.bind(this);\n    this.setInput = this.setInput.bind(this);\n    this.setInputs = this.setInputs.bind(this);\n    this.setInputStateOnly = this.setInputStateOnly.bind(this);\n    this.setMetaframeClientInputAndSentClientEvent = this.setMetaframeClientInputAndSentClientEvent.bind(this);\n    this.setOutputStateOnly = this.setOutputStateOnly.bind(this);\n    this.setState = this.setState.bind(this);\n\n    window.addEventListener(\"message\", this.onMessage);\n\n    this.log(\"Initialized\");\n  }\n\n  addListenerReturnDisposer(event : MetapageEvents | OtherEvents, listener : ListenerFn<any[]>): () => void {\n    super.addListener(event, listener);\n    const disposer = () => {\n      super.removeListener(event, listener);\n    };\n    return disposer;\n  }\n\n  public setDebugFromUrlParams(): Metapage {\n    this.debug = existsAnyUrlParam([\"MP_DEBUG\", \"DEBUG\", \"debug\", \"mp_debug\"]);\n    return this;\n  }\n\n  public getState(): MetapageState {\n    return this._state;\n  }\n\n  // public onState(listener : Listener): () => void {\n  //   var disposer = this.addListener(MetapageEvents.State, listener);\n  //   listener(this._state);\n  //   return disposer;\n  // }\n\n  public setState(newState : MetapageState) {\n    this._state = newState;\n    this.getMetaframeIds().forEach(metaframeId => {\n      this.getMetaframe(metaframeId).setInputs(this._state.metaframes.inputs[metaframeId]);\n      this.getMetaframe(metaframeId).setOutputs(this._state.metaframes.outputs[metaframeId]);\n    });\n    this.getPluginIds().forEach((pluginId:string) => {\n      this.getPlugin(pluginId).setInputs(this._state.plugins.inputs[pluginId]);\n      this.getPlugin(pluginId).setOutputs(this._state.plugins.outputs[pluginId]);\n    });\n    this.emit(MetapageEvents.State, this._state);\n  }\n\n  public getStateMetaframes(): MetapageStatePartial {\n    return this._state.metaframes;\n  }\n\n  public getDefinition(): MetapageDefinition | undefined {\n    return this._definition;\n  }\n\n  public setDefinition(def : any, state? : MetapageState): Metapage {\n    // Some validation\n    // can metaframes and plugins share IDs? No.\n    const newDefinition :MetapageDefinition = convertToCurrentDefinition(def);\n    if (newDefinition.metaframes) {\n      Object.keys(newDefinition.metaframes).forEach(metaframeId => {\n        if (newDefinition.plugins && newDefinition.plugins.includes(metaframeId)) {\n          this.emitErrorMessage(`Plugin with url=${metaframeId} matches metaframe. Metaframe ids and plugin urls are not allowed to collide`);\n          throw `Plugin with url=${metaframeId} matches metaframe. Metaframe ids and plugin urls are not allowed to collide`;\n        }\n\n        var metaframeDefinition = newDefinition.metaframes[metaframeId];\n        if (typeof metaframeDefinition !== \"object\") {\n          this.emitErrorMessage(`Metaframe \"${metaframeId}\" is not an object`);\n          throw `Metaframe \"${metaframeId}\" is not an object`;\n        }\n\n        if (!metaframeDefinition.url) {\n          this.emitErrorMessage(`Metaframe \"${metaframeId}\" missing field: url`);\n          throw `Metaframe \"${metaframeId}\" missing field: url`;\n        }\n      });\n    }\n\n    // save previous to compare?\n    // var previous = this._definition;\n\n    this._definition = newDefinition;\n    // try to be efficient with the new definition.\n    // destroy any metaframes not in the new definition\n    Object.keys(this._metaframes).forEach(metaframeId => {\n      // Doesn't exist? Destroy it\n      if (!newDefinition.metaframes || !newDefinition.metaframes[metaframeId]) {\n        // this removes the metaframe, pipes, inputs, caches\n        this.removeMetaframe(metaframeId);\n      }\n    });\n\n    // destroy any plugins not in the new definition\n    Object.keys(this._plugins).forEach(url => {\n      // Doesn't exist? Destroy it\n      if (newDefinition.plugins && !newDefinition.plugins.includes(url)) {\n        this.removePlugin(url);\n      }\n    });\n\n    // the plugin order\n    this._pluginOrder = newDefinition.plugins\n      ? newDefinition.plugins\n      : [];\n\n    // if the state is updated, set that now\n    if (state) {\n      this._state = state;\n    }\n\n    // Create any new metaframes needed\n    if (newDefinition.metaframes) {\n      Object.keys(newDefinition.metaframes).forEach(newMetaframeId => {\n        if (!this._metaframes.hasOwnProperty(newMetaframeId)) {\n          const metaframeDefinition = newDefinition.metaframes[newMetaframeId];\n          this.addMetaframe(newMetaframeId, metaframeDefinition);\n        }\n      });\n    }\n\n    // Create any new plugins\n    if (newDefinition.plugins) {\n      newDefinition.plugins.forEach(url => {\n        if (!this._plugins.hasOwnProperty(url)) {\n          this.addPlugin(url);\n        }\n      });\n    }\n\n    // TODO set the state of the new pieces? That should happen in the addMetaframe/addPlugin methods I think\n\n    // Send the event on the next loop to give listeners time to re-add\n    // after this method returns.\n    const event: MetapageEventDefinition = {\n      definition: this._definition,\n      metaframes: this._metaframes,\n      plugins: this._plugins\n    };\n    window.setTimeout(() => {\n      this.emit(MetapageEvents.Definition, event);\n      if (state) {\n        this.emit(MetapageEvents.State, this._state);\n      }\n    }, 0);\n\n    return this;\n  }\n\n  // do not expose, change definition instead\n  addPipe(target : MetaframeId, input : PipeInput) {\n    // Do all the cache checking\n    if (!this._inputMap[target]) {\n      this._inputMap[target] = [];\n    }\n    this._inputMap[target].push(input);\n  }\n\n  // do not expose, change definition instead\n  removeMetaframe(metaframeId : MetaframeId) {\n    if (!this._metaframes[metaframeId]) {\n      return;\n    }\n\n    this._metaframes[metaframeId].dispose();\n    delete this._metaframes[metaframeId];\n    delete this._state.metaframes.inputs[metaframeId];\n    delete this._state.metaframes.outputs[metaframeId];\n\n    delete this._inputMap[metaframeId];\n    Object.keys(this._inputMap).forEach(otherMetaframeId => {\n      const inputPipes = this._inputMap[otherMetaframeId];\n      let index = 0;\n      while (index <= inputPipes.length) {\n        if (inputPipes[index].metaframe == metaframeId) {\n          inputPipes.splice(index, 1);\n        } else {\n          index++;\n        }\n      }\n    });\n\n    // This will regenerate, simpler than surgery\n    this._cachedInputLookupMap = {};\n  }\n\n  // do not expose, change definition instead\n  // to add/remove\n  removePlugin(url : Url): void {\n    if (!this._plugins[url]) {\n      return;\n    }\n\n    this._plugins[url].dispose();\n    delete this._plugins[url];\n    delete this._state.plugins.inputs[url];\n    delete this._state.plugins.outputs[url];\n  }\n\n  // do not expose, change definition instead\n  // to add/remove\n  removeAll(): void {\n    Object.keys(this._metaframes).forEach(id => this._metaframes[id].dispose());\n    Object.keys(this._plugins).forEach(id => this._plugins[id].dispose());\n    this._metaframes = {};\n    this._plugins = {};\n    this._state = emptyState();\n    this._inputMap = {};\n    this._cachedInputLookupMap = {};\n  }\n\n  public metaframes() {\n    return this.getMetaframes();\n  }\n\n  public metaframeIds(): MetaframeId[]{\n    return this.getMetaframeIds();\n  }\n\n  public getMetaframeIds(): MetaframeId[]{\n    return Object.keys(this._metaframes);\n  }\n\n  public getMetaframes(): {\n    [key: string]: IFrameRpcClient;\n  } {\n    //<MetaframeId,IFrameRpcClient>\n    return Object.assign({}, this._metaframes);\n  }\n\n  public plugins(): {\n    [key: string]: IFrameRpcClient;\n  } {\n    //<Url,IFrameRpcClient>\n    return Object.assign({}, this._plugins);\n  }\n\n  public pluginIds(): Array<Url> {\n    return this.getPluginIds();\n  }\n\n  public getPluginIds(): Array<Url> {\n    return this._pluginOrder.slice(0);\n  }\n\n  public getMetaframe(id : MetaframeId): IFrameRpcClient {\n    return this._metaframes[id];\n  }\n\n  public getPlugin(url : string): IFrameRpcClient {\n    return this._plugins[url];\n  }\n\n  // do not expose, change definition instead\n  addMetaframe(metaframeId : MetaframeId, definition : MetaframeInstance): IFrameRpcClient {\n    if (!metaframeId) {\n      throw \"addMetaframe missing metaframeId\";\n    }\n\n    if (!definition) {\n      throw \"addMetaframe missing definition\";\n    }\n\n    if (this._metaframes[metaframeId]) {\n      this.emitErrorMessage(`Existing metaframe for id=${metaframeId}`);\n      throw `Existing metaframe for id=${metaframeId}`;\n    }\n\n    if (!definition.url) {\n      this.emitErrorMessage(`Metaframe definition missing url id=${metaframeId}`);\n      throw `Metaframe definition missing url id=${metaframeId}`;\n    }\n\n    var iframeClient = new IFrameRpcClient(this, definition.url, metaframeId, this._id, this._consoleBackgroundColor, this.debug).setMetapage(this);\n    this._metaframes[metaframeId] = iframeClient;\n\n    // add the pipes\n    if (definition.inputs) {\n      definition.inputs.forEach(input => this.addPipe(metaframeId, input));\n    }\n\n    // set the initial inputs\n    iframeClient.setInputs(this._state.metaframes.inputs[metaframeId]);\n\n    return iframeClient;\n  }\n\n  // do not expose, change definition instead\n  addPlugin(url : Url): IFrameRpcClient {\n    if (!url) {\n      throw \"Plugin missing url\";\n    }\n\n    var iframeClient = new IFrameRpcClient(this, url, url, this._id, this._consoleBackgroundColor, this.debug).setInputs(this._state.plugins.inputs[url]).setMetapage(this).setPlugin();\n\n    this._plugins[url] = iframeClient;\n\n    return iframeClient;\n  }\n\n  public dispose() {\n    super.removeAllListeners();\n    window.removeEventListener(\"message\", this.onMessage);\n    if (this._metaframes) {\n      Object.keys(this._metaframes).forEach(metaframeId => this._metaframes[metaframeId].dispose());\n    }\n    if (this._plugins) {\n      Object.keys(this._plugins).forEach(pluginId => this._plugins[pluginId].dispose());\n    }\n\n    // help the gc remove references but ignore the TS warnings as this object is now gone so don't touch it\n    // @ts-ignore\n    this._id = undefined;\n    // @ts-ignore\n    this._metaframes = undefined;\n    // @ts-ignore\n    this._plugins = undefined;\n    // @ts-ignore\n    this._state = undefined;\n    this._definition = undefined;\n    // @ts-ignore\n    this._cachedInputLookupMap = undefined;\n    // @ts-ignore\n    this._inputMap = undefined;\n  }\n\n  public log(o : any, color? : string, backgroundColor? : string) {\n    if (!this.debug) {\n      return;\n    }\n    this.logInternal(o, color, backgroundColor);\n  }\n\n  public error(err : any) {\n    this.logInternal(err, \"f00\", this._consoleBackgroundColor);\n    this.emitErrorMessage(`${err}`);\n  }\n\n  public emitErrorMessage(err : string) {\n    this.emit(MetapageEvents.Error, err);\n  }\n\n  // This call is cached\n  getInputsFromOutput(source : MetaframeId, outputPipeId : MetaframePipeId): MetaframeInputTargetsFromOutput[]{\n    // Do all the cache checking\n    if (!this._cachedInputLookupMap[source]) {\n      this._cachedInputLookupMap[source] = {};\n    }\n\n    if (!this._cachedInputLookupMap[source][outputPipeId]) {\n      var targets: MetaframeInputTargetsFromOutput[] = [];\n      this._cachedInputLookupMap[source][outputPipeId] = targets;\n      // Go through the data structure, getting all the matching inputs that match this output\n      Object.keys(this._inputMap).forEach(metaframeId => {\n        if (metaframeId === source) {\n          // No self pipes, does not make sense\n          return;\n        }\n        this._inputMap[metaframeId].forEach(inputPipe => {\n          // At least the source metaframe matches, now check pipes\n          if (inputPipe.metaframe == source) {\n            //Check the kind of source string\n            // it could be a basic string, or a glob?\n            if (minimatch(outputPipeId, inputPipe.source)) {\n              // A match, now figure out the actual input pipe name\n              // since it might be * or absent meaning that the input\n              // field name is the same as the incoming\n              var targetName = inputPipe.target;\n              if (!inputPipe.target || inputPipe.target.startsWith(\"*\") || inputPipe.target === \"\") {\n                targetName = outputPipeId;\n              }\n              targets.push({metaframe: metaframeId, pipe: targetName});\n            }\n          }\n        });\n      });\n    }\n\n    return this._cachedInputLookupMap[source][outputPipeId];\n  }\n\n  isValidJSONRpcMessage(message : MinimumClientMessage<any>) {\n    if (message.jsonrpc !== \"2.0\") {\n      // do not even log messages that we do not recogize. We cannot control random scripts sending messages on\n      // the only communications channel\n      return false;\n    }\n    const method = message.method as JsonRpcMethodsFromChild;\n    switch (method) {\n      case JsonRpcMethodsFromChild.SetupIframeClientRequest:\n        //No validation possible here\n        return true;\n      default:\n        // TODO: check origin+source\n        var iframeId: MetaframeId | undefined = message.iframeId;\n        if (iframeId && !(message.parentId === this._id && (this._metaframes[iframeId] || this._plugins[iframeId]))) {\n        // if (iframeId && !(message.parentId === this._id && this._metaframes[iframeId])) {\n          // this.error(`message.parentId=${message.parentId} this._id=${this._id} message.iframeId=${iframeId} this._metaframes.hasOwnProperty(message.iframeId)=${this._metaframes[iframeId] !== undefined} this._plugins.hasOwnProperty(message.iframeId)=${this._plugins[iframeId] !== undefined} message=${JSON.stringify(message).substr(0, 200)}`);\n          return false;\n        }\n        return true;\n    }\n  }\n\n  /**\n   * Sets inputs\n   * First update internal state, so any events that check get the new value\n   * Then update the metaframe clients\n   * Fire events\n   * @param iframeId Can be an object of {metaframeId:{pipeId:value}} or the metaframe/plugin id\n   * @param inputPipeId If the above is a string id, then inputPipeId can be the pipe id or an object {pipeId:value}\n   * @param value If the above is a pipe id, then the is the value.\n   */\n  public setInput(iframeId : any, inputPipeId? : any, value? : any) {\n    this.setInputStateOnly(iframeId, inputPipeId, value);\n    this.setMetaframeClientInputAndSentClientEvent(iframeId, inputPipeId, value);\n    // finally send the main events\n    this.emit(MetapageEvents.State, this._state);\n    this.emit(MetapageEvents.Inputs, this._state);\n  }\n\n  // this is\n  setMetaframeClientInputAndSentClientEvent(iframeId : any, inputPipeId? : any, value? : any) {\n    if (typeof iframeId === \"object\") {\n      if (inputPipeId || value) {\n        throw \"bad arguments, see API docs\";\n      }\n      const inputs: any = iframeId;\n      Object.keys(inputs).forEach(id => {\n        var metaframeId: MetaframeId = id;\n        var metaframeInputs = inputs[metaframeId];\n        if (typeof metaframeInputs !== \"object\") {\n          throw \"bad arguments, see API docs\";\n        }\n        var iframeClient = this._metaframes[metaframeId];\n        if (iframeClient) {\n          iframeClient.setInputs(metaframeInputs);\n        } else {\n          this.error(\"No iframe id=$metaframeId\");\n        }\n      });\n    } else if (typeof iframeId === \"string\") {\n      const iframeClient = this._metaframes[iframeId];\n      if (iframeClient == null) {\n        this.error(`No iframe id=${iframeId}`);\n      }\n      if (typeof inputPipeId === \"string\") {\n        iframeClient.setInput(inputPipeId, value);\n      } else if (typeof inputPipeId === \"object\") {\n        iframeClient.setInputs(inputPipeId);\n      } else {\n        throw \"bad arguments, see API docs\";\n      }\n    } else {\n      throw \"bad arguments, see API docs\";\n    }\n  }\n\n  public setInputs(iframeId : any, inputPipeId? : any, value? : any) {\n    this.setInput(iframeId, inputPipeId, value);\n  }\n\n  setOutputStateOnly(iframeId : any, inputPipeId? : any, value? : any) {\n    this._setStateOnly(false, iframeId, inputPipeId, value);\n  }\n\n  // Set the global inputs cache\n  setInputStateOnly(iframeId : any, inputPipeId? : any, value? : any) {\n    this._setStateOnly(true, iframeId, inputPipeId, value);\n  }\n\n  // need to set the boolean first because we don't know the metaframe/pluginId until we dig into\n  // the object. but it might not be an object. this flexibility might not be worth it, although\n  // the logic is reasonble to test\n  _setStateOnly(isInputs : boolean, iframeId : any, inputPipeId? : any, value? : any) {\n    if (typeof iframeId === \"object\") {\n      // it's an object of metaframeIds to pipeIds to values [metaframeId][pipeId]\n      // so the other fields should be undefined\n      if (inputPipeId || value) {\n        throw \"If first argument is an object, subsequent args should be undefined\";\n      }\n      const inputsMetaframesNew: MetapageInstanceInputs = iframeId;\n      Object.keys(inputsMetaframesNew).forEach(metaframeId => {\n        var metaframeValuesNew: MetaframeInputMap = inputsMetaframesNew[metaframeId];\n        if (typeof metaframeValuesNew !== \"object\") {\n          throw \"Object values must be objects\";\n        }\n\n        const isMetaframe = this._metaframes.hasOwnProperty(metaframeId);\n        if (!isMetaframe && !this._plugins.hasOwnProperty(metaframeId)) {\n          throw \"No metaframe or plugin: ${metaframeId}\";\n        }\n        // if (!isMetaframe) {\n        //   throw \" No metaframe: ${metaframeId}\";\n        // }\n        const inputOrOutputState = isMetaframe\n          ? isInputs\n            ? this._state.metaframes.inputs\n            : this._state.metaframes.outputs\n          : isInputs\n            ? this._state.plugins.inputs\n            : this._state.plugins.outputs;\n\n        // Ensure a map\n        inputOrOutputState[metaframeId] = inputOrOutputState[metaframeId]\n          ? inputOrOutputState[metaframeId]\n          : ({} as MetaframeInstance);\n\n        Object.keys(metaframeValuesNew).forEach(metaframePipedId => {\n          // A key with a value of undefined means remove the key from the state object\n          if (metaframeValuesNew[metaframePipedId] === undefined) {\n            delete inputOrOutputState[metaframeId][metaframePipedId];\n          } else {\n            // otherwise set the new value\n            inputOrOutputState[metaframeId][metaframePipedId] = metaframeValuesNew[metaframePipedId];\n          }\n        });\n      });\n    } else if (typeof iframeId === \"string\") {\n      const metaframeId: MetaframeId = iframeId;\n      const isMetaframe = this._metaframes.hasOwnProperty(metaframeId);\n      if (!isMetaframe && !this._plugins.hasOwnProperty(metaframeId)) {\n        throw `No metaframe or plugin: ${metaframeId}`;\n      }\n      // console.log('Object.keys(this._metaframes)', Object.keys(this._metaframes));\n      // console.log('Object.keys(this._plugins)', Object.keys(this._plugins));\n      // if (!isMetaframe) {\n      //   throw ` No metaframe: ${metaframeId}`;\n      // }\n      const inputOrOutputState = isMetaframe\n        ? isInputs\n          ? this._state.metaframes.inputs\n          : this._state.metaframes.outputs\n        : isInputs\n          ? this._state.plugins.inputs\n          : this._state.plugins.outputs;\n\n      if (typeof inputPipeId === \"string\") {\n        // Ensure a map\n        inputOrOutputState[metaframeId] = inputOrOutputState[metaframeId]\n          ? inputOrOutputState[metaframeId]\n          : ({} as MetaframeInstance);\n\n        const metaframePipeId: MetaframePipeId = inputPipeId;\n\n        // A key with a value of undefined means remove the key from the state object\n        if (value === undefined) {\n          delete inputOrOutputState[metaframeId][metaframePipeId];\n        } else {\n          // otherwise set the new value\n          inputOrOutputState[metaframeId][metaframePipeId] = value;\n        }\n      } else if (typeof inputPipeId === \"object\") {\n        // Ensure a map\n        inputOrOutputState[metaframeId] = inputOrOutputState[metaframeId]\n          ? inputOrOutputState[metaframeId]\n          : ({} as MetaframeInstance);\n\n        const metaframeValuesNew: MetaframeInputMap = inputPipeId;\n\n        Object.keys(metaframeValuesNew).forEach(metaframePipedId => {\n          // A key with a value of undefined means remove the key from the state object\n          if (metaframeValuesNew[metaframePipedId] === undefined) {\n            delete inputOrOutputState[metaframeId][metaframePipedId];\n          } else {\n            // otherwise set the new value\n            inputOrOutputState[metaframeId][metaframePipedId] = metaframeValuesNew[metaframePipedId];\n          }\n        });\n      } else {\n        throw \"Second argument must be a string or an object\";\n      }\n    } else {\n      throw \"First argument must be a string or an object\";\n    }\n  }\n\n  getMetaframeOrPlugin(key : string): IFrameRpcClient {\n    // TODO: this is not good, it will lead to subtle bugs, fix it\n    var val = this._metaframes[key];\n    if (!val) {\n      val = this._plugins[key];\n    }\n    return val;\n  }\n\n  onMessage(e : any) {\n    if (typeof e.data === \"object\") {\n      const jsonrpc = e.data as MinimumClientMessage<any>;\n      if (!this.isValidJSONRpcMessage(jsonrpc)) {\n        return;\n      }\n      // var origin :string = untyped e.origin;\n      // var source :IFrameElement = untyped e.source;\n      //Verify here\n      var method = jsonrpc.method as JsonRpcMethodsFromChild;\n\n      switch (method) {\n        /**\n         * An iframe has created a connection object.\n         * Here we register it to set up a secure\n         * communication channel between other\n         * iframe clients.\n         * Any time *any* SetupIframeClientRequest\n         * message is received, send the appropriate\n         * response to all clients, since we do not\n         * know who sent the SetupIframeClientRequest.\n         * The response is idempotent (already registerd\n         * metaframes ignore further registration requests).\n         */\n        case JsonRpcMethodsFromChild.SetupIframeClientRequest:\n          Object.keys(this._metaframes).forEach(metaframeId => {\n            const iframeClient = this._metaframes[metaframeId];\n            iframeClient.register();\n          });\n\n          Object.keys(this._plugins).forEach(url => {\n            const iframeClient = this._plugins[url];\n            iframeClient.register();\n          });\n          break;\n\n          /* A client iframe responded */\n        case JsonRpcMethodsFromChild.SetupIframeServerResponseAck:\n          /* Send all inputs when a client has registered. */\n          if (jsonrpc.iframeId) {\n            var params = jsonrpc.params as SetupIframeClientAckData<any>;\n            var metaframe = this.getMetaframeOrPlugin(jsonrpc.iframeId);\n            metaframe.registered(params.version);\n          }\n          break;\n\n        case JsonRpcMethodsFromChild.OutputsUpdate:\n          var metaframeId: MetaframeId | undefined = jsonrpc.iframeId;\n          if (!metaframeId) {\n            break;\n          }\n\n          var outputs: MetaframeInputMap = jsonrpc.params;\n\n          if (this.debug)\n            this.log(`outputs from ${metaframeId}: ${JSON.stringify(outputs, null, '  ').substr(0, 100)}`);\n\n          if (this._metaframes[metaframeId]) {\n            var iframe = this._metaframes[metaframeId];\n\n            // set the internal state, no event yet, nor downstream inputs update (yet)\n            this.setOutputStateOnly(metaframeId, outputs);\n            // iframe outputs, metaframe only event sent\n            iframe.setOutputs(outputs);\n            // now sent metapage event\n            this.emit(MetapageEvents.State, this._state);\n\n            // cached lookup of where those outputs are going\n            var modified = false;\n            Object.keys(outputs).forEach(outputKey => {\n              const targets :MetaframeInputTargetsFromOutput[] = this.getInputsFromOutput(metaframeId!, outputKey);\n              if (targets.length > 0) {\n                targets.forEach(target => {\n                  var inputBlob: MetaframeInputMap = {};\n                  inputBlob[target.pipe] = outputs[outputKey];\n                  // update the metapage state first (no events)\n                  this.setInputStateOnly(target.metaframe, target.pipe, outputs[outputKey]);\n                  // setting the individual inputs sends an event\n                  this._metaframes[target.metaframe].setInputs(inputBlob);\n                  modified = true;\n                });\n              }\n            });\n            // only send a state event if downstream inputs were modified\n            if (modified) {\n              this.emit(MetapageEvents.State, this._state);\n            }\n            if (this.debug) {\n              iframe.ack({jsonrpc: jsonrpc, state: this._state});\n            }\n          }\n          else if (this._plugins[metaframeId]) {\n            // the metapage state special pipes (definition and global state)\n            // are not persisted in the plugin state\n            const outputPersistanceAllowed = !outputs[METAPAGE_KEY_STATE] && !outputs[METAPAGE_KEY_DEFINITION];\n            if (outputPersistanceAllowed) {\n              this.setOutputStateOnly(metaframeId, outputs);\n            }\n            // it might not seem meaningful to set the plugin outputs, since plugin outputs\n            // do not flow into other plugin inputs. However, the outputs are specifically\n            // listened to, for the purposes of e.g. setting the definition or state\n            this._plugins[metaframeId].setOutputs(outputs);\n\n            // TODO: question\n            // I'm not sure if plugin outputs should trigger a state event, since it's not\n            // metaframe state.\n            if (outputPersistanceAllowed) {\n              this.emit(MetapageEvents.State, this._state);\n            }\n            if (this.debug) {\n              this._plugins[metaframeId].ack({jsonrpc: jsonrpc, state: this._state});\n            }\n          }\n          else {\n            this.error(`missing metaframe/plugin=$metaframeId`);\n          }\n\n          break;\n\n        case JsonRpcMethodsFromChild.InputsUpdate:\n          // logInternal(\"metapage InputsUpdate \" + JSON.stringify(jsonrpc, null, \"  \"));\n          // This is triggered by the metaframe itself, meaning the metaframe\n          // decided to save this state info.\n          // We store it in the local state, then send it back so\n          // the metaframe is notified of its input state.\n          var metaframeId: MetaframeId | undefined = jsonrpc.iframeId;\n          if (!metaframeId) {\n            break;\n          }\n          // #if jsondiff\n          // \t\t\t\t\tlogDiff = getDiffRelease('${metaframeId}: ${method}');\n          // #end\n          var inputs: MetaframeInputMap = jsonrpc.params;\n          if (this.debug)\n            this.log(`inputs ${JSON.stringify(inputs)} from ${metaframeId}`);\n          if (this._metaframes[metaframeId]) {\n            // Set the internal inputs state first so that anything that\n            // responds to events will get the updated state if requested\n            // Currently on for setting metaframe inputs that haven't loaded yet\n            // logInternal('metaframe ${metaframeId} _metaframes[metaframeId] ');\n            this.setInputStateOnly(metaframeId, inputs);\n\n            switch (this._metaframes[metaframeId].version) {\n                // These old versions create a circular loop of inputs updating\n                // if you just set the inputs here. Those internal metaframes\n                // already have notified their own listeners, so just emit\n                // events but do not process the inputs further\n                // Emitting the events causes the internal state to get updated.\n              case Versions.V0_0_1:\n              case Versions.V0_1_0:\n                this._metaframes[metaframeId].emit(MetapageEvents.Inputs, inputs);\n                if (this.listenerCount(MetapageEvents.Inputs) > 0) {\n                  var metaframeInputs: MetapageInstanceInputs = {};\n                  metaframeInputs[metaframeId] = inputs;\n                  this.emit(MetapageEvents.Inputs, metaframeInputs);\n                }\n                break;\n              default:\n                // New versions can safely set their inputs here, their\n                // own internal listeners have not yet been notified.\n                // logInternal('metaframe ${metaframeId} setInputs ' + JSON.stringify(inputs, null, \"  \"));\n                this._metaframes[metaframeId].setInputs(inputs);\n                break;\n            }\n            this.emit(MetapageEvents.State, this._state);\n            if (this.debug) {\n              this._metaframes[metaframeId].ack({jsonrpc: jsonrpc, state: this._state});\n            }\n          }\n          else if (this._plugins[metaframeId]) {\n            // the metapage state special pipes (definition and global state)\n            // are not persisted in the plugin state\n            const inputPersistanceAllowed = !inputs[METAPAGE_KEY_STATE] && !inputs[METAPAGE_KEY_DEFINITION];\n            if (inputPersistanceAllowed) {\n              this.setInputStateOnly(metaframeId, inputs);\n            }\n            this._plugins[metaframeId].setInputs(inputs);\n            if (inputPersistanceAllowed) {\n              this.emit(MetapageEvents.State, this._state);\n            }\n            if (this.debug) {\n              this._plugins[metaframeId].ack({jsonrpc: jsonrpc, state: this._state});\n            }\n          }\n          else {\n            console.error(`InputsUpdate failed no metaframe or plugin id: \"${metaframeId}\"`);\n            this.error(`InputsUpdate failed no metaframe or plugin id: \"${metaframeId}\"`);\n          }\n          break;\n        case JsonRpcMethodsFromChild.PluginRequest:\n          var pluginId = jsonrpc.iframeId;\n          if (!pluginId) {\n            break;\n          }\n          // #if jsondiff\n          // \t\t\t\t\tlogDiff = getDiffRelease('${pluginId}: ${method}');\n          // #end\n          if (this._plugins[pluginId] && this._plugins[pluginId].hasPermissionsState()) {\n            this._plugins[pluginId].setInput(METAPAGE_KEY_STATE, this._state);\n            if (this.debug) {\n              this._plugins[pluginId].ack({jsonrpc: jsonrpc, state: this._state});\n            }\n          }\n          break;\n        default:\n          if (this.debug) {\n            this.log(`Unknown RPC method: \"${method}\"`);\n          }\n      }\n      // #if jsondiff\n      // \t\t\tif (logDiff) logDiff();\n      // #end\n\n      this.emit(OtherEvents.Message, jsonrpc);\n    }\n  }\n\n  logInternal(o : any, color? : string, backgroundColor? : string) {\n    backgroundColor = backgroundColor\n      ? backgroundColor\n      : this._consoleBackgroundColor;\n    let s: string;\n    if (typeof o === \"string\") {\n      s = o as string;\n    } else if (typeof o === \"number\") {\n      s = o + \"\";\n    } else {\n      s = JSON.stringify(o);\n    }\n    s = this._id\n      ? `Metapage[${this._id}] ${s}`\n      : s;\n    MetapageToolsLog(s, color, backgroundColor);\n  }\n}\n\n\nclass IFrameRpcClient extends EventEmitter < JsonRpcMethodsFromParent | MetapageEvents > {\n  iframe: HTMLIFrameElement;\n  id: MetaframeId;\n  version: Versions | undefined;\n  // Used for securing postMessage\n  url: string;\n  _color: string;\n  _consoleBackgroundColor: string;\n  _ready: Promise<void>;\n  inputs: MetaframeInputMap = {};\n  outputs: MetaframeInputMap = {};\n  _disposables: (() => void)[] = [];\n  _rpcListeners: ((r : JsonRpcRequest<any>) => void)[] = [];\n  _loaded: boolean = false;\n  _onLoaded: (() => void)[] = [];\n  _parentId: MetapageId;\n  _debug: boolean;\n  _sendInputsAfterRegistration: boolean = false;\n  _definition: MetaframeDefinition | undefined;\n  _plugin: boolean = false;\n\n  _metapage: Metapage;\n\n  constructor(metapage :Metapage, url : string, iframeId : MetaframeId, parentId : MetapageId, consoleBackgroundColor : string, debug : boolean = false) {\n    super();\n    // Url sanitation\n    // Urls can be relative paths, if so, turn them into absolute URLs\n    // Also local development often skips the \"http:\" part, so add that\n    // on so the origin is valid\n    if (!url.startsWith(\"http\")) {\n      while (url.startsWith(\"/\")) {\n        url = url.substr(1);\n      }\n      url = window.location.protocol + \"//\" + window.location.hostname + (\n        window.location.port && window.location.port != \"\"\n        ? \":\" + window.location.port\n        : \"\") + \"/\" + url;\n    }\n    this.url = url;\n    this._metapage = metapage;\n\n    // Add the custom URL params\n    var urlBlob = new URL(this.url);\n    if (debug) {\n      urlBlob.searchParams.set(URL_PARAM_DEBUG, \"1\");\n    }\n    this.url = urlBlob.href;\n\n    this.id = iframeId;\n    this.iframe = document.createElement(\"iframe\");\n    // this.iframe.scrolling = \"no\";\n    this.iframe.src = this.url;\n    this._debug = debug || existsAnyUrlParam([\n      \"DEBUG_METAFRAMES\", \"debug_metaframes\", \"debug_\" + this.id,\n      \"DEBUG_\" + this.id\n    ]);\n    this.iframe.frameBorder = \"0\";\n    this._parentId = parentId;\n    this._color = stringToRgb(this.id);\n    this._consoleBackgroundColor = consoleBackgroundColor;\n\n    this._ready = new Promise((resolve, _) => {\n      this.iframe.addEventListener('load', (_) => {\n        resolve();\n      });\n    });\n\n    this.ack = this.ack.bind(this);\n    this.bindPlugin = this.bindPlugin.bind(this);\n    this.dispose = this.dispose.bind(this);\n    this.getDefinition = this.getDefinition.bind(this);\n    this.getDefinitionUrl = this.getDefinitionUrl.bind(this);\n    this.setPlugin = this.setPlugin.bind(this);\n    this.hasPermissionsDefinition = this.hasPermissionsDefinition.bind(this);\n    this.hasPermissionsState = this.hasPermissionsState.bind(this);\n    this.log = this.log.bind(this);\n    this.logInternal = this.logInternal.bind(this);\n    this.onInput = this.onInput.bind(this);\n    this.onInputs = this.onInputs.bind(this);\n    this.onOutput = this.onOutput.bind(this);\n    this.onOutputs = this.onOutputs.bind(this);\n    this.register = this.register.bind(this);\n    this.registered = this.registered.bind(this);\n    this.sendInputs = this.sendInputs.bind(this);\n    this.sendOrBufferPostMessage = this.sendOrBufferPostMessage.bind(this);\n    this.sendRpc = this.sendRpc.bind(this);\n    this.sendRpcInternal = this.sendRpcInternal.bind(this);\n    this.setInput = this.setInput.bind(this);\n    this.setInputs = this.setInputs.bind(this);\n    this.setMetapage = this.setMetapage.bind(this);\n    this.setOutput = this.setOutput.bind(this);\n    this.setOutputs = this.setOutputs.bind(this);\n    this.setPlugin = this.setPlugin.bind(this);\n    this.addListenerReturnDisposer = this.addListenerReturnDisposer.bind(this);\n\n  }\n\n  addListenerReturnDisposer(event : JsonRpcMethodsFromParent | MetapageEvents, listener : ListenerFn<any[]>): () => void {\n    super.addListener(event, listener);\n    const disposer = () => {\n      super.removeListener(event, listener);\n    };\n    return disposer;\n  }\n\n  public setPlugin(): IFrameRpcClient {\n    if (this._loaded) {\n      throw \"Cannot setPlugin after IFrameRpcClient already loaded\";\n    }\n    this._plugin = true;\n    this.bindPlugin();\n    return this;\n  }\n\n  public setMetapage(metapage : Metapage): IFrameRpcClient {\n    this._metapage = metapage;\n    return this;\n  }\n\n  /**\n   * Plugins can get and set the metapage definition and state.\n   * The inputs/outputs of the plugin MUST define those inputs\n   * otherwise the\n   * @return Promise<boolean>\n   */\n  async bindPlugin() {\n    //   1) check for metapage/definition inputs and outputs\n    //\t\t- if found, wire up listeners and responses and send current definition\n    //   2) check for metapage/state inputs and outputs\n    //\t\t- if found, listen for JSON-RPC events from that plugin and send the state.\n    //      - if found, set the entire state on 'metapage/state' output\n    try {\n      const metaframeDef = await this.getDefinition();\n      // definition get/set\n      // send the metapage/definition immediately\n      // on getting a metapage/definition value, set that\n      // value on the metapage itself.\n      // console.log(`bindPlugin id=${this.id} hasPermissionsDefinition()  ${this.hasPermissionsDefinition()}`);\n\n      if (this.hasPermissionsDefinition()) {\n        var disposer = this._metapage.addListenerReturnDisposer(MetapageEvents.Definition, definition => {\n          this.setInput(METAPAGE_KEY_DEFINITION, definition.definition);\n        });\n        this._disposables.push(disposer);\n        // we do not need to send the current actual definition, because\n        // a MetapageEvents.Definition event will be fired subsequent to adding this\n        // Set the metapage definition now, otherwise it will not ever get\n        // the event.\n        var currentMetapageDef = this._metapage.getDefinition();\n        this.setInput(METAPAGE_KEY_DEFINITION, currentMetapageDef);\n\n        if (metaframeDef.outputs) {\n          var disposer = this.onOutput(METAPAGE_KEY_DEFINITION, definition => {\n            // trace('_metapage.setDefinition, definition=${definition}');\n            this._metapage.setDefinition(definition);\n          });\n          this._disposables.push(disposer);\n        }\n      }\n\n\n      if (this.hasPermissionsState()) {\n        // if the plugin sets the metapage state, set it here\n        if (metaframeDef.outputs) {\n          var disposer = this.onOutput(METAPAGE_KEY_STATE, state => {\n            this._metapage.setState(state);\n          });\n          this._disposables.push(disposer);\n        }\n      }\n    } catch (err) {\n      console.error(err);\n      this._metapage.emit(MetapageEvents.Error, `Failed to get plugin definition from \"${this.getDefinitionUrl()}\", error=${err}`);\n    }\n  }\n\n  public hasPermissionsState(): boolean {\n    return (this._definition  !== undefined && this._definition.inputs !== undefined && this._definition.inputs![METAPAGE_KEY_STATE] !== undefined);\n  }\n\n  public hasPermissionsDefinition(): boolean {\n    return (this._definition  !== undefined && this._definition.inputs !== undefined && this._definition.inputs![METAPAGE_KEY_DEFINITION] !== undefined);\n  }\n\n  public getDefinitionUrl(): string {\n    var url = new URL(this.url);\n    url.pathname = url.pathname + (\n      url.pathname.endsWith(\"/\")\n      ? \"metaframe.json\"\n      : \"/metaframe.json\");\n    return url.href;\n  }\n\n  public async getDefinition(): Promise<MetaframeDefinition> {\n    if(this._definition) {\n      return this._definition;\n    }\n    var url = this.getDefinitionUrl();\n    const response = await window.fetch(url);\n    const metaframeDef = await response.json();\n    this._definition = metaframeDef;\n    return metaframeDef;\n  }\n\n  public setInput(name : MetaframePipeId, inputBlob : any) {\n    console.assert(!!name);\n    var inputs: MetaframeInputMap = {};\n    inputs[name] = inputBlob;\n    this.setInputs(inputs);\n  }\n\n  /**\n   * Sends the updated inputs to the iframe\n   */\n  _cachedEventInputsUpdate :{iframeId:string|undefined, inputs:MetaframeInputMap|undefined}= {\n    iframeId: undefined,\n    inputs: undefined\n  };\n  public setInputs(maybeNewInputs : MetaframeInputMap): IFrameRpcClient {\n    // console.log(' IFrameRpcClient.setInputs', maybeNewInputs);\n    // this.log({m:'IFrameRpcClient', inputs:maybeNewInputs});\n    if (!merge(this.inputs, maybeNewInputs)) {\n      // console.log(' IFrameRpcClient.setInputs failed merge');\n      return this;\n    }\n    if (!this._loaded) {\n      // console.log(' IFrameRpcClient.setInputs !this._loaded');\n      this._sendInputsAfterRegistration = true;\n    }\n    // Only send the new inputs to the actual metaframe iframe\n    // if it's not registered, don't worry, inputs are merged,\n    // and when the metaframe is registered, current inputs will\n    // be sent\n    if (this.iframe.parentNode && this._loaded) {\n      this.sendInputs(maybeNewInputs);\n      // } else {\n      // \tlog('Not setting input bc this._loaded=$_loaded');\n    }\n\n    // Notify\n    // console.log(' IFrameRpcClient.setInputs emitting!');\n    this.emit(MetapageEvents.Inputs, this.inputs);\n    if (this._metapage.listenerCount(MetapageEvents.Inputs) > 0) {\n      var inputUpdate: MetapageInstanceInputs = {};\n      inputUpdate[this.id] = maybeNewInputs;\n      this._metapage.emit(MetapageEvents.Inputs, inputUpdate);\n    }\n    //TODO is this really used anymore?\n    this._cachedEventInputsUpdate.iframeId = this.id;\n    this._cachedEventInputsUpdate.inputs = this.inputs;\n    this._metapage.emit(JsonRpcMethodsFromParent.InputsUpdate, this._cachedEventInputsUpdate);\n\n    return this;\n  }\n\n  public setOutput(pipeId : MetaframePipeId, updateBlob : any) {\n    console.assert(!!pipeId);\n    var outputs: MetaframeInputMap = {};\n    outputs[pipeId] = updateBlob;\n    this.setOutputs(outputs);\n  }\n\n  _cachedEventOutputsUpdate = {\n    iframeId: null,\n    inputs: null\n  };\n  public setOutputs(maybeNewOutputs : MetaframeInputMap) {\n    if (!merge(this.outputs, maybeNewOutputs)) {\n      return;\n    }\n    this.emit(MetapageEvents.Outputs, maybeNewOutputs);\n\n    // for (outputPipeId in maybeNewOutputs.keys()) {\n    // \tlog('output [${outputPipeId}]');\n    // }\n    if (this._metapage.listenerCount(MetapageEvents.Outputs) > 0) {\n      var outputsUpdate: MetapageInstanceInputs = {};\n      outputsUpdate[this.id] = this.outputs;\n      this._metapage.emit(MetapageEvents.Outputs, outputsUpdate);\n    }\n  }\n\n  public onInputs(f : (m : MetaframeInputMap) => void): () => void {\n    return this.addListenerReturnDisposer(MetapageEvents.Inputs, f);\n  }\n\n  public onInput(pipeName : MetaframePipeId, f : (_ : any) => void): () => void {\n    var fWrap = function (inputs : MetaframeInputMap) {\n      if (inputs.hasOwnProperty(pipeName)) {\n        f(inputs[pipeName]);\n      }\n    };\n    return this.addListenerReturnDisposer(MetapageEvents.Inputs, fWrap);\n  }\n\n  public onOutputs(f : (m : MetaframeInputMap) => void): () => void {\n    return this.addListenerReturnDisposer(MetapageEvents.Outputs, f);\n  }\n\n  public onOutput(pipeName : MetaframePipeId, f : (_ : any) => void): () => void {\n    var fWrap = function (outputs : MetaframeInputMap) {\n      if (outputs.hasOwnProperty(pipeName)) {\n        f(outputs[pipeName]);\n      }\n    };\n    return this.addListenerReturnDisposer(MetapageEvents.Outputs, fWrap);\n  }\n\n  public dispose() {\n    super.removeAllListeners();\n    while (this._disposables && this._disposables.length > 0) {\n      const val = this._disposables.pop();\n      if (val) {\n        val();\n      }\n    }\n    // @ts-ignore\n    this._rpcListeners = undefined;\n    // @ts-ignore\n    this.inputs = undefined;\n    // @ts-ignore\n    this.outputs = undefined;\n    // @ts-ignore\n    this._ready = undefined;\n    if (this.iframe && this.iframe.parentNode) {\n      this.iframe.parentNode.removeChild(this.iframe);\n    }\n    // @ts-ignore\n    this.iframe = undefined;\n    // @ts-ignore\n    this._bufferMessages = undefined;\n    if (this._bufferTimeout) {\n      window.clearInterval(this._bufferTimeout);\n      // @ts-ignore\n      this._bufferTimeout = undefined;\n    }\n    // @ts-ignore\n    this._metapage = undefined;\n  }\n\n  /**\n   * Request that the parent metapage tell us what our id is\n   */\n  public register() {\n    if (this._loaded) {\n      return;\n    }\n\n    var response: SetupIframeServerResponseData = {\n      iframeId: this.id,\n      parentId: this._parentId,\n      plugin: this._plugin,\n      state: {\n        inputs: this.inputs\n      },\n      version: Metapage.version as Versions\n    };\n    this.sendRpcInternal(JsonRpcMethodsFromParent.SetupIframeServerResponse, response);\n  }\n\n  public registered(version : Versions) {\n    if (this._loaded) {\n      return;\n    }\n    this.version = version;\n    // Only very old versions don't send their version info\n    // Obsoleted?\n    if (this.version == null) {\n      this.version = Versions.V0_1_0;\n    }\n    this._loaded = true;\n    while (this._onLoaded && this._onLoaded.length > 0) {\n      this._onLoaded.pop()!();\n    }\n    // You still need to set the inputs even though they\n    // may have been set initially, because the inputs may\n    // have been been updated before the metaframe internal\n    // returned its server ack.\n    if (this._sendInputsAfterRegistration) {\n      this.sendInputs(this.inputs);\n    }\n    // this.log('registered version=${this.version}');\n  }\n\n  sendInputs(inputs : MetaframeInputMap) {\n    // console.log(' IFrameRpcClient.sendInputs', inputs);\n    this.sendRpc(JsonRpcMethodsFromParent.InputsUpdate, {\n      inputs: inputs,\n      parentId: this._parentId\n    });\n  }\n\n  public sendRpc(method : string, params : any) {\n    if (this.iframe.parentNode && this._loaded) {\n      this.sendRpcInternal(method, params);\n    } else {\n      this._metapage.error(\"sending rpc later\");\n      const thing = this;\n      this._onLoaded.push(() => {\n        thing.sendRpcInternal(method, params);\n      });\n    }\n  }\n\n  public ack(message : any) {\n    this.log(\"   calling ack\");\n    if (this._debug) {\n      this.log(\"   sending ack from client to frame\");\n      var payload: ClientMessageRecievedAck<any> = {\n        message: message\n      };\n      this.sendRpc(JsonRpcMethodsFromParent.MessageAck, payload);\n    } else {\n      this.log(\"   NOT sending ack from client to frame since not debug mode\");\n    }\n  }\n\n  public log(o : any) {\n    if (!this._debug) {\n      return;\n    }\n    this.logInternal(o);\n  }\n\n  logInternal(o : any) {\n    let s: string;\n    if (typeof o === \"string\") {\n      s = o as string;\n    } else if (typeof o === \"string\") {\n      s = o + \"\";\n    } else {\n      s = JSON.stringify(o);\n    }\n    MetapageToolsLog(`Metapage[${this._parentId}] Metaframe[$id] ${s}`, this._color, this._consoleBackgroundColor);\n  }\n\n  sendRpcInternal(method : string, params : any) {\n    const messageJSON: MinimumClientMessage<any> = {\n      id: \"_\",\n      iframeId: this.id,\n      jsonrpc: \"2.0\",\n      method: method,\n      params: params,\n      parentId: this._parentId\n    };\n    if (this.iframe) {\n      this.sendOrBufferPostMessage(messageJSON);\n    } else {\n      this._metapage.error(\"Cannot send to child iframe messageJSON=${JSON.stringify(messageJSON).substr(0, 200)}\");\n    }\n  }\n\n  _bufferMessages: any[] | undefined;\n  _bufferTimeout: number|undefined;\n  sendOrBufferPostMessage(message : any) {\n    // if (!this.iframe || !this.iframe.contentWindow) {\n    //   console.log('no this.iframe.contentWindow, not sending message');\n    // }\n    if (this.iframe && this.iframe.contentWindow) {\n      this.iframe.contentWindow.postMessage(message, this.url);\n    } else {\n      if (!this._bufferMessages) {\n        this._bufferMessages = [message];\n        const thing = this;\n        this._bufferTimeout = window.setInterval(function () {\n          if (thing.iframe && thing.iframe.contentWindow) {\n            thing._bufferMessages!.forEach(m => thing.iframe!.contentWindow!.postMessage(m, thing.url));\n            window.clearInterval(thing._bufferTimeout);\n            thing._bufferTimeout = undefined;\n            thing._bufferMessages = undefined;\n          }\n        }, 0);\n      } else {\n        this._bufferMessages.push(message);\n      }\n    }\n  }\n}\n"]}