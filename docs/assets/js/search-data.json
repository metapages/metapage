{"0": {
    "doc": "Use cases",
    "title": "Use cases",
    "content": "# Use cases See examples. ",
    "url": "https://metapages.org/pages/documentation/01-use-cases.html",
    "relUrl": "/pages/documentation/01-use-cases.html"
  },"1": {
    "doc": "Creating a metapage",
    "title": "Creating a metapage",
    "content": "# How do I create a metapage? See examples. ",
    "url": "https://metapages.org/pages/documentation/02-creating.html",
    "relUrl": "/pages/documentation/02-creating.html"
  },"2": {
    "doc": "Data Flow",
    "title": "Data Flow",
    "content": "# Metapage Data flow *** metapage sends *inputs* to metaframe metaframe setup sequenceDiagram participant P as metapage participant F as metaframe P->>F: creation F-->>P: register request Note right of P: unknown origin Note right of P: sent to all P->>F: {state, iframeId, parentId} Note right of F: registered (once) Note right of F: initial inputs set Note right of F: send update events *** metaframe sets inputs sequenceDiagram participant P as metapage participant F as metaframe Note right of F: sets inputs F-->>P: new inputs Note right of P: stores updates only Note right of F: send update events *** metaframe sets outputs sequenceDiagram participant P as metapage participant F as metaframe Note right of F: sets outputs F-->>P: new outputs Note right of P: stores updates Note right of P: send downstream Note right of F: this is a different Note right of F: child metaframe P-->>F: new inputs ",
    "url": "https://metapages.org/pages/documentation/03_data-flow.html",
    "relUrl": "/pages/documentation/03_data-flow.html"
  },"3": {
    "doc": "API",
    "title": "API",
    "content": "# API Reference v0.8.0 {: .no_toc } ###### previous versions {: .no_toc } ## {: .no_toc .text-delta } 1. TOC {:toc} MetapageDefinition ----- The JSON description consists of metaframes and the metaframe inputs. Example minimal metapage with two metaframes: graph LR metaframe1[\"random-data-generator\"] -- \"y -> y\" --> metaframe2[\"graph-dynamic\"] Defined by: ```json { \"version\": \"0.3\", \"meta\": { \"layouts\": { \"flexboxgrid\" : { \"docs\": \"http://flexboxgrid.com/\", \"layout\": [ [ {\"name\":\"random-data-generator\", \"width\":\"col-xs-4\", \"style\": {\"maxHeight\":\"600px\"}}, {\"url\":\"{{site.url}}/metaframes/passthrough-arrow/?rotation=90\", \"width\":\"col-xs-1\"}, {\"name\":\"graph-dynamic\", \"width\":\"col-xs-7\"} ] ] } } }, \"metaframes\": { \"random-data-generator\": { \"url\": \"{{site.url}}/metaframes/random-data-generator/?frequency=1000\" }, \"graph-dynamic\": { \"url\": \"{{site.url}}/metaframes/graph-dynamic/\", \"inputs\": [ { \"metaframe\": \"random-data-generator\", \"source\": \"y\" } ] } }, \"plugins\": [ \"{{site.url}}/metaframes/mermaid.js/?TITLE=0\", \"{{site.url}}/metaframes/passthrough/\", {% if jekyll.environment == \"production\" %} \"https://editor.mtfm.io/\" {% else %} \"{{site.data.urls.metaframe-editor-json-local}}\" {% endif %} ] } ``` {% if jekyll.environment == \"production\" %} [Run above example](https://app.metapages.org/#?url={{site.url}}{{site.baseurl}}/metapages/dynamic-plot/metapage.json){: .btn .btn-green } {% else %} [Run above example]({{site.data.urls.app-metapage-local}}/#?url={{site.url}}{{site.baseurl}}/metapages/dynamic-plot/metapage.json){: .btn .btn-green } {% endif %} To run the same example as the button above: 1. copy the JSON definition above 2. paste into the example text box at [https://app.metapages.org/)]({% if jekyll.environment == \"production\" %}https://app.metapages.org/{% else %}({{site.data.urls.app-metapage-local}}/){% endif %}). The `pipe` entries of \"inputs\" are objects describing the source metaframe, source metaframe output pipe name, and the target metaframe (the owning metaframe) input pipe name ```js { \"metaframe\": \"\", \"source\": \"\", \"target\": \" | \", } ``` `pipe.metaframe`: source metaframeId `pipe.source`: source metaframe output pipe name. Can be `*` or any glob, this will forward all output pipes matching the glob `pipe.target`: (optional) target metaframe input pipe name. If `target` is omitted, then the input pipe name will be the same as the output pipe name. graph LR metaframeSource[pipeInput.metaframe] -- \"pipeInput.source -> pipeInput.target\" --> targetMetaframe `version`: This library hasn't reached version `\"1\"` yet. Backwards compatibility is built into this library from it's first release, and will be automated as much as possible. This is required to maintain long-term compatibility: metaframes should be useful forever, if that is possible from the content. Users should only need to upgrade for bug fixes, performance improvements, or to access new features, and there should never be cognitive load (no worries) about versioning for library users. Mistakes happen, no process is perfect, but this tool assumes the burden of handling all changes to versions over time. --- Metapage ----- A metapage manages piping metaframe outputs to metaframe inputs. Ways to initialize a metapage: 1. Load a `metapage.json` dynamically and add the metaframes. If no `loadCallback` is given, metaframe iframes will automatically be added to the document element with the id that matches the metaframe id: ```ts Metapage.load(?metapage :, ?loadCallback :func): Promise ``` `metapage`: URL to metapage definition, defaults to \"metapage.json\", or the metapage JSON object `loadCallback`: optional callback with two arguments `(metaframeId, IFrameElement)` 2. Create a metapage from a [MetapageDefinition](#metapagedefinition) JSON object. No metaframes are yet added to the page: ```ts const metapage = Metapage.from(def :MetapageDefinition, ?opts :Options): Metapage // updating the definition metapage.setDefinition(def :MetapageDefinition) ``` The optional ```opts``` argument defineds some extra options, mostly used for debugging: ```typescript interface Options { color?: String; // Color of console.logs, since all iframes and the main page will output logs to the same console id? : String; // Id, not required, but useful if you have multiple metapages in a single website. } ``` ### Metapage#setDebugFromUrlParams ```ts metapage.setDebugFromUrlParams() ``` If the URL has one of the parameters `MP_DEBUG`, `mp_debug`, `DEBUG`, `debug`, then debug logging is enabled, e.g.: `https://domain.org/metapage1?debug`. The metapage and metaframes will output coloured console logs (the color is randomly but deterministically computed from the respective id). ### Metapage#dispose ```ts metapage.dispose() ``` Removes all metaframes, window listeners, event listeners. ### Metapage#getMetaframe ```ts metapage.getMetaframe(metaframeId :String): MetaframeClient ``` Get the MetaframeClient for the given id. ### Metapage#getMetaframeIds ```ts metapage.metaframeIds(): Array ``` Returns an array of metaframe ids. ### Metapage#getMetaframes() ```ts metapage.getMetaframes(): Map ``` Returns a plain Object with metaframe ids mapped to MetaframeClient objects. ### Metapage#getPluginIds ```ts metapage.getPluginIds(): Array ``` Returns an array of plugin ids. ### Metapage#getPlugins() ```ts metapage.getPlugins(): Map ``` Returns a plain Object with metaframe ids mapped to MetaframeClient objects. ### Metapage#getState() ```ts metapage.getState(): State ``` Where `State` looks like: ```json { \"metaframes\": { \"inputs\": { \"metaframeId1\": { \"inputPipe1\": true } } } ``` It represents the entire state of the metapage. ### Metapage#setState() ```ts metapage.setState(state :State) ``` This will update the entire state of the application and set all the metaframe inputs. ### Metapage#onState() ```ts metapage.onState(function(state :State) { ... }); ``` The callback is called on every state change. ### Metapage#setDefinition() ```ts metapage.setDefinition(def :Definition) ``` ### Metapage#getDefinition() ```ts var def :Definition = metapage.getDefinition(); ``` ### Metapage#onInputs ```ts metapage.getMetaframe().onInputs(function(inputs) {...}): function(): ``` Callback called on every input update event. Example `inputs` payload: ```js { \"inputPipeId1\": \"value\" } ``` An unbind function is returned. The same thing can be called via the event: ```ts metapage.getMetaframe().on('inputs', function(inputs) {...}): function(): ``` You can also listen on the metaframe clients directly: ```ts metapage.get(metaframeId).on('inputs', function(inputs) {...}): function(): ``` ### Metapage#onOutputs ```ts metapage.get(metaframeId).onOutputs(function(outputs) {...}): function(): ``` Callback called on every output update event. Example `outputs` payload: ```js { \"outputPipeId1\": \"value\" } ``` An unbind function is returned. The same thing can be called via the event: ```ts metapage.get(metaframeId).on('outputs', function(outputs) {...}): function(): ``` ### Metapage#removeAll ```ts metapage.removeAll() ``` Removes all metaframes, essentially resetting the metapage. It doesn't remove window listeners though, for proper disposal call `dispose()`. ### Metapage#setInput/setInputs Set metaframe inputs a variety of ways (there is no difference between `setInput/setInputs` calls). ```ts metapage.setInput(metaframeId :String, inputPipeId :String, value :any) metapage.setInput(metaframeId :String, inputsObject :any) metapage.setInput(metaframeInputsObject :any) ``` `inputsObject`: ```js { \"inputPipeName\": \"some value\" } ``` `metaframeInputsObject`: ```js { \"metaframeId\": { \"inputPipeName\": \"some value\" } } ``` ### Metapage#setDefinition Update the metapage definition. This will destroy the current metaframes and plugins, and recreate new ones based on the new definition. The ### Metapage events ### Metapage#STATE Metapage event allows you to add hooks to the data flow: ```js /** * Example update: * { * \"metaframes\": { * \"inputs\": { * \"metaframe1\": { * \"input1\": \"foobar\", * \"input2\": 3 * } * } * } * } */ metapage.on('state', function(metapageState) { ...}); metapage.on(Metapage.STATE, function(definition) { ... }); ``` Listens to changes in the `state` for metaframes (and plugins). The listener is called on every discrete update of inputs and outputs. ### Metapage#DEFINITION ```ts /** * Example definition event: * { * \"definition\": { }, * \"metaframes\": { * \"metaframe1\": { \"url\": \"{{site.url}}/metaframes/example1/\" }, * \"metaframe2\": { \"url\": \"{{site.url}}/metaframes/example2/\" } * }, * \"plugins\": [ * { \"plugin1\": \"https://plugin1.io\" }, * { \"plugin2\": \"https://plugin2.io\" } * ] * } */ metapage.on('definition', function(definition) { ... }); metapage.on(Metapage.DEFINITION, function(definition) { ... }); metapage.setDefinition(def :MetapageDefinition); // Fires above event metapage.getDefinition(def) :MetapageDefinition; ``` The definition can be updated, this will fire on every change and give the full definition. It also returns the metaframe and plugin sets, with the objects needed to e.g. add the iframe objects to the DOM. This is the main event you should listen to if your metapage gets updated. ### Metapage#ERROR ```ts metapage.on('error', function(definition) { ... }); metapage.on(Metapage.ERROR, function(definition) { ... }); metapage.setDefinition(def :MetapageDefinition); // Fires above event metapage.getDefinition(def) :MetapageDefinition; ``` The definition can be updated, this will fire on every change and give the full definition. ### Metapage.MetaframeClient An internal object managing the data flow in and out of the actual metaframe iframe. You shouldn't need to access this object directly. This object is in the *metapage* page, managing the metaframe data flow. ### Metapage.MetaframeClient#?url ```ts // The URL of the underlying iframe const url :string = metapage.getMetaframe(id).url; ``` ### Metapage.MetaframeClient#iframe A promise returning the metaframe [iframe](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe) HTML element. This must be a promise because the `metaframe.json` file is downloaded and used to help construct the iframe (e.g. permissions) ### Metapage.MetaframeClient#dispose ```ts metaframe.dispose() ``` Removes all event listeners and clears internal objects. ### Metapage.MetaframeClient#onInputs ```ts metapage.get(metaframeId).onInputs(function(inputs) {...}): function(): ``` Callback called on every input update event. Only the *new* inputs are in the payload, not all inputs. Example `inputs` payload: ```js { \"inputPipeId1\": \"value\" } ``` An unbind function is returned. The same thing can be called via the event: ```ts metapage.get(metaframeId).on('inputs', function(inputs) {...}): function(): ``` ### Metapage.MetaframeClient#onOutputs ```ts metapage.get(metaframeId).onOutputs(function(outputs) {...}): function(): ``` Callback called on every output update event. Example `outputs` payload: ```js { \"outputPipeId1\": \"value\" } ``` An unbind function is returned. The same thing can be called via the event: ```ts metapage.get(metaframeId).on('outputs', function(outputs) {...}): function(): ``` Metaframe ----- A metaframe is a website running the metaframe library that adds input+output data pipes to the page. Metaframes optionally have a `metaframe.json` definition at the URL path root, defining e.g. name, and the inputs and outputs. The definition is not *strictly* needed, however is is very helpful. Some metaframes, such as plugins, do require the `metaframe.json` to declare what inputs/outputs are allowed. You need to specify a version. All metaframe versions will be compatible with all metapage versions, however some new functionality will obviously not be available with using older versions. ```json { \"version\": \"0.3\", \"metadata\": { \"title\": \"A button example\", \"author\": \"Dion Whitehead\" }, \"inputs\": { \"input_name\": { \"type\": \"json\" } }, \"outputs\": { \"output_name\": { \"type\": \"string\" } } } ``` Initialize a metaframe: ```ts const metaframe = new Metaframe(); ``` Wait until it has registered and established a connection with the parent *metapage*: ```ts await metaframe.ready ``` or: ```ts metaframe.ready.then(function(_) { //Do something, set inputs/outputs }); ``` ### Metaframe#id ```ts let s :String = metaframe.id; ``` The id the metapage assigned to this metaframe. Defaults to the key in the metapage definition. ### Metaframe#getInput ```ts let inputValue = metaframe.getInput('inputName') ``` ### Metaframe#getInputs ```ts let inputValues = metaframe.getInputs() ``` Get a object of input pipe names mapped to values. Do not modify the returned object! For efficiency purposes this is *not* a copy. ### Metaframe#getOutput ```ts let output = metaframe.getOutput('outputName') ``` ### Metaframe#getOutputs ```ts let outputs = metaframe.getOutputs() ``` Do not modify the returned object! For efficiency purposes this is *not* a copy. ### Metaframe#onInputs ```ts metaframe.onInputs(function(inputs) {...}): function(): ``` Callback called on every input update event. The payload is only the *new* inputs, not all current inputs. Example `inputs` payload: ```js { \"inputPipeId1\": \"value\" } ``` Do not modify the returned object! For efficiency purposes this is *not* a copy. An unbind function is returned. ### Metaframe#onInput ```ts metaframe.onInput('inputName', function(value) {...}): function(): ``` The callback will fire with the value of the input pipe on every update. An unbind function is returned. ### Metaframe#setInput ```ts metaframe.setInput('inputName', value :any) ``` ### Metaframe#setOutput ```ts metaframe.setOutput('outputName', value :any) ``` This value will be send to all downstream metaframe consumers. ### Metaframe#setOutput ```ts metaframe.setOutputs(values :Object) ``` `values`: object mapping output names to values. These values will be send to all downstream metaframe consumers. ### Metaframe#dispose ```ts metaframe.dispose() ``` Removes window message listener, event listeners, and nulls potentially large fields. # Plugins Metapage plugins are metaframes that are not connected to the normal metaframes, instead they have hooks (via inputs) into: - metapage state changes (the metaframe inputs + outputs) - the metapage definition Uses for the above include: - saving and restoring state changes - displaying representations of the definition (graph views, JSON editors) - others things currently outside my imagination They are defined in the definition as unique URL to the plugin metaframe: ```json { \"metaframes\": { ... }, \"plugins\": [ \"https://plugin1.io\", \"https://plugin2.io?param1=value1\" ] } ``` The order of the plugins is usually the order displayed in the [app.metapages.org](https://app.metapages.org) UI. The plugin URLs must be unique (even though they are defined in a list) and are not allowed to collide with the metaframe ids. ## Implenting a metapage plugin Plugins declare which inputs they are allows to receive in the `metaframe.json` definition located at the base of the URL path. The outputs declare which values they will emit. All supported values are in this example plugin metaframe definition: ```json { \"version\": \"0.3\", \"metadata\": { \"title\": \"My metapage plugin\" }, \"inputs\": { \"metapage/state\": { \"type\": \"json\" }, \"metapage/definition\": { \"type\": \"json\" } }, \"outputs\": { \"metapage/state\": { \"type\": \"json\" }, \"metapage/definition\": { \"type\": \"json\" } } } ``` ## Metaframe#plugin The `plugin` field on the `metapage` object will be present if the metaframe is initialized as a plugin by the owning metapage: ```ts metaframe.plugin ``` `metapage/definition` and `metapage/state` pipes may be listened to as per usual, or you may call the plugin methods: ## Metaframe#plugin.requestState ## Metaframe#plugin.onState Requests the current state from the metapage. ```ts metaframe.plugin.requestState(); // arrives via the next line var disposeFunction = metaframe.plugin.onState(function(metapageState) { ... }); ``` ## Metaframe#plugin.setState ```ts metaframe.plugin.setState(metapageState); ``` ## Metaframe#plugin.onDefinition ## Metaframe#plugin.setDefinition ## Metaframe#plugin.getDefinition ```ts var disposeFunction = metaframe.plugin.onDefinition(function(metapageDefinition) { ... }); metaframe.plugin.setDefinition(metapageDefinition); var definition = metaframe.plugin.getDefinition); ``` ## Metaframe#plugin pipes `metapage/definition`: this input will always have the most recent metapage definition. If the output is set, the metapage will update the definition. No action is needed to get this data. `metapage/state`: this input has the metapage state. If the output is set, the metapage will update the entire application state. The `metapage/state` is not sent automatically, it must be requested every time: ",
    "url": "https://metapages.org/api/",
    "relUrl": "/api/"
  },"4": {
    "doc": "Install/Download",
    "title": "Install/Download",
    "content": "# Installing ## Browsers ### In the metaframe html: ```html ``` ```javascript import { Metaframe } from \"@metapages/metapage\"; const metaframe = new Metaframe(); ``` ### In the metapage html: ```html ``` ```javascript import { Metapage } from \"@metapages/metapage\"; const metapage = Metapage.from(...) ``` ## webpack/node.js/grunt etc ```bash npm i --save @metapages/metapage ``` ## Promise This library is meant to be a piece of the puzzle of preserving scientific information (among other things) over time. As such, we promise, to the best of our ability and resources, to maintain a maximum level of backwards and forwards compatibility between as many versions as possible betwen the two interacting libraries. ",
    "url": "https://metapages.org/install/",
    "relUrl": "/install/"
  },"5": {
    "doc": "Tools",
    "title": "Tools",
    "content": "## Metapage tools . {% if jekyll.environment == \"production\" %} | Metapage Viewer | {% else %} | Metapage Viewer | {% endif %} . ## Metaframe tools . | Metaframe Viewer | . ",
    "url": "https://metapages.org/tools/",
    "relUrl": "/tools/"
  },"6": {
    "doc": "Plugins",
    "title": "Plugins",
    "content": "Plugins are slightly special metaframe sites. See the [api docs](/api/#plugins) ",
    "url": "https://metapages.org/plugins/",
    "relUrl": "/plugins/"
  },"7": {
    "doc": "Test",
    "title": "Test",
    "content": "We strive to make all versions of the metaframe library compatible with all versions of the metapage library. {% if jekyll.environment == \"production\" %} So we [display the tests of version vs version]({{site.baseurl}}/pages/test/index.html) {% else %} So we [display the tests of version vs version]({{site.baseurl}}/pages/test/index.html?VERSION=latest) {% endif %} ",
    "url": "https://metapages.org/test/",
    "relUrl": "/test/"
  },"8": {
    "doc": "About",
    "title": "About",
    "content": "[Privacy Policy](/privacy.html) [Terms of Service](/tos.html) ",
    "url": "https://metapages.org/about/",
    "relUrl": "/about/"
  },"9": {
    "doc": "Documentation",
    "title": "Documentation",
    "content": " ",
    "url": "https://metapages.org/documentation/",
    "relUrl": "/documentation/"
  },"10": {
    "doc": "Examples",
    "title": "Examples",
    "content": "## Example Metapages |:--------------------|:-----------------------|:------------------------| {%- for metapage in site.metapages -%} {%- if metapage.url contains 'index.html' -%} {%- assign tokens = metapage.url | remove: \"/index.html\" | split: \"/\" -%} {%- assign token = tokens.last -%} {%- if jekyll.environment == \"production\" -%} {%- assign url = \"https://app.metapages.org/#?url=\" | append: site.url | append: site.baseurl | append: \"/metapages/\" | append: token | append: \"/metapage.json\" -%} {%- else -%} {%- assign url = site.data.urls.app-metapage-local | append: \"#?url=\" | append: site.url | append: site.baseurl | append: \"/metapages/\" | append: token | append: \"/metapage.json\" -%} {%- endif -%} {%- if token == \"test\" -%} {%- assign url = site.baseurl | append: \"/metapages/\" | append: token -%} {%- endif -%} {%- assign urlJson = site.url | append: site.baseurl | append: \"/metapages/\" | append: token | append: \"/metapage.json\" -%} {%- assign urlDebug = url | append: \"?DEBUG\" %} | [{{ token }}]({{ url }}) | [debug]({{ urlDebug }}) | [Metapage JSON definition]({{ urlJson }}) | {%- endif -%} {% endfor %} ## Example Metaframes |:--------------------|:-----------------------|:------------------------| {%- for metaframe in site.metaframes -%} {%- if metaframe.url contains 'index.html' -%} {%- assign index = metaframe.url | remove: \"index.html\" -%} {%- assign tokens = metaframe.url | remove: \"/index.html\" | split: \"/\" -%} {%- assign token = tokens.last -%} {%- assign urlJson = site.baseurl | append: index | append: \"metaframe.json\" -%} {%- assign inspect = site.url | append: site.baseurl | append: \"/tools/metaframeview?url=\" | append: site.url | append: site.baseurl | append: \"/metaframes/\" | append: token | append: \"/\" %} | [{{ token }}]({{site.baseurl}}{{ index }}) | [Inspect]({{ inspect }}) | [JSON Definition]({{ urlJson }}) | {%- endif -%} {% endfor %} {%- assign externalMetaframes = \"https://editor.mtfm.io/\" | split: \",\" -%} {%- for metaframeUrl in externalMetaframes -%} {%- if jekyll.environment != \"production\" -%} {%- assign metaframeUrl = \"https://editor.mtfm.io/\" | prepend: \"http://localhost:3000/\" -%} {%- endif -%} {%- assign urlJson = site.baseurl | metaframeUrl | append: \"metaframe.json\" -%} {%- assign inspect = site.url | append: site.baseurl | append: \"/tools/metaframeview?url=\" | append: metaframeUrl %} | [{{ metaframeUrl }}]({{ metaframeUrl }}) | [Inspect]({{ inspect }}) | [JSON Definition]({{ urlJson }}) | {% endfor %} ## Tools {% if jekyll.environment == \"production\" -%} {%- assign appUrl = \"https://app.metapages.org/\" -%} {%- else -%} {%- assign appUrl = site.data.urls.app-metapage-local -%} {%- endif %} |Description |:-------------------------|:-----------------------| [{{appUrl}}]({{appUrl}}) | Run any metapage (JSON) as a standalone application. Used to run the metapage examples above. Follow link for more details. | ## Plugins [Plugin examples](https://github.com/metapages/metapage/issues/36) are coming soon. ",
    "url": "https://metapages.org/examples/",
    "relUrl": "/examples/"
  },"11": {
    "doc": "Introduction",
    "title": "Introduction",
    "content": "# What is a *metapage*? A metapage is a webpage that consists of **embedded** and **connected** webpages. Embedded webpages are called **metaframes**. A metaframe can be any webpage that runs a small piece of javascript code that creates data pipes. An example metapage showing two metaframes, one generating randome data, the other plotting whatever date it gets: {% if jekyll.environment == \"production\" %} [https://app.metapages.org/?header=0#?url={{site.url}}{{site.baseurl}}/metapages/dynamic-plot/](https://app.metapages.org/?header=0#?url={{site.url}}{{site.baseurl}}/metapages/dynamic-plot/) {% else %} [{{site.data.urls.app-metapage-local}}?header=0#?url={{site.url}}{{site.baseurl}}/metapages/dynamic-plot/]({{site.data.urls.app-metapage-local}}?header=0#?url={{site.url}}{{site.baseurl}}/metapages/dynamic-plot/) {% endif %} The two pages above are completely separate websites, and have no idea about the other. One simply passes data to the other, controlled by the metapage code running in the parent page. # Why would you want to do this? Browsers are an ideal platform to distribute applications: they are readily available, HTML/Javascript/CSS will run the same on all browsers, updates are trivial to push, and they are quite performant. A website can crunch data, show interactive plots and graphics, allow sophisticated user interaction. In other words, all manner of useful things. When you have somethine like a website that is specialized and does something well, eventually people want to combine useful pieces into a bigger whole. These are metapages. # How do I create a metapage? See the docs for more detailed documentation. ",
    "url": "https://metapages.org/",
    "relUrl": "/"
  },"12": {
    "doc": "versions",
    "title": "versions",
    "content": "## API versions {% assign versions = site.versions | sort: 'name' | reverse %} {% for version in versions %} {{ version.version }} ```html ``` {% endfor %} ",
    "url": "https://metapages.org/versions/",
    "relUrl": "/versions/"
  }
}
